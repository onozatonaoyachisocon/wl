<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’åº¦è©¦é¨“çµæœãƒ»æ•´ç†ã‚·ã‚¹ãƒ†ãƒ </title>
   <link rel="icon" href='data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ğŸ“Š</text></svg>'>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.min.js"></script>
    
    <!-- Handsontable v6.2.2 -->
    <script src="https://cdn.jsdelivr.net/npm/handsontable@6.2.2/dist/handsontable.full.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/handsontable@6.2.2/dist/handsontable.full.min.css" />

    <style>
/* --- å…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ --- */
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: "Helvetica Neue", Arial, sans-serif; height: 100vh; display: flex; overflow: hidden; background: #f4f6f7; color: #333; }

/* --- ã‚µã‚¤ãƒ‰ãƒãƒ¼ --- */
.sidebar { width: 320px; background-color: #1e2634; color: #ecf0f1; padding: 15px; display: flex; flex-direction: column; gap: 15px; overflow-y: auto; border-right: 1px solid #000; flex-shrink: 0; z-index: 10; }
.sidebar-title { display: flex; align-items: center; justify-content: center; margin-bottom: 10px; color: #fff; font-size: 16px; font-weight: bold; text-align: center; line-height: 1.4; }
.sidebar-panel { background: #2c3e50; padding: 10px; border-radius: 6px; border: 1px solid #455a64; margin-bottom: 0; transition: all 0.2s; }
.sidebar h3 { margin: 0 0 10px 0; font-size: 13px; color: #bdc3c7; border-bottom: 1px solid #555; padding-bottom: 5px; }

/* ã‚µã‚¤ãƒ‰ãƒãƒ¼éƒ¨å“ */
.collapsible-header { cursor: pointer; display: flex; justify-content: space-between; align-items: center; user-select: none; }
.collapsible-header:hover { color: #fff; }
.arrow-icon { font-size: 10px; transition: transform 0.2s; }
.control-item { margin-bottom: 12px; }
.control-label { display: block; font-size: 12px; color: #ccc; margin-bottom: 4px; }
select.dark-input, input[type="number"].dark-input { width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #555; background: #34495e; color: #fff; font-size: 13px; }
label.toggle { display: flex; align-items: center; cursor: pointer; font-size: 12px; user-select: none; color: #ecf0f1; padding: 4px 0; }
label.toggle input { margin-right: 8px; }

.btn-group { display: flex; gap: 5px; margin-bottom: 5px; }
.btn-sidebar { flex: 1; padding: 8px; border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 12px; font-weight: bold; text-align: center; display: inline-flex; align-items: center; justify-content: center; transition: opacity 0.2s; }
.btn-sidebar:hover { opacity: 0.9; }
.btn-blue { background-color: #2980b9; }
.btn-green { background-color: #27ae60; }
.btn-orange { background-color: #d35400; }
.btn-gray { background-color: #7f8c8d; }
.btn-purple { background-color: #8e44ad; }
.help-icon { background: #6c757d; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; font-weight: bold; cursor: pointer; margin-left: 10px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }

/* --- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ --- */
#main-content { flex-grow: 1; display: flex; flex-direction: column; overflow-y: auto; padding: 20px; background: #f4f6f7; position: relative; }

/* --- ãƒãƒ£ãƒ¼ãƒˆé…ç½®ã‚¨ãƒªã‚¢ (Gridå¯¾å¿œ) --- */
.charts-wrapper, .composition-wrapper { 
    display: grid;
    grid-template-columns: 1fr; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ1åˆ— */
    gap: 24px;
    align-items: start; /* é«˜ã•ãŒä¸æƒã„ã§ã‚‚ä¸Šæƒãˆã«ã™ã‚‹ */
}
.cols-2 { grid-template-columns: repeat(2, 1fr); }
.cols-3 { grid-template-columns: repeat(3, 1fr); }

/* --- ãƒãƒ£ãƒ¼ãƒˆBOX (ã‚«ãƒ¼ãƒ‰å‹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ) --- */
.chart-box {
    background: white;
    border-radius: 8px;
    border: 1px solid #e5e7eb;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    margin-bottom: 0;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    width: 100%;
    min-width: 0;
}
.chart-header-bar {
    background-color: #f3f4f6;
    padding: 8px 15px;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 48px;
    flex-shrink: 0;
}
.chart-title-html {
    font-size: 14px;
    font-weight: bold;
    color: #111827;
    margin: 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 60%;
}
.chart-actions-static { display: flex; align-items: center; gap: 8px; }

/* â˜…â˜…â˜… æ–°ãƒ»ãƒãƒ£ãƒ¼ãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ (å‡¡ä¾‹å¯¾å¿œ) â˜…â˜…â˜… */
.chart-body {
    display: flex;
    flex-direction: column; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: ç¸¦ä¸¦ã³ (å‡¡ä¾‹ä¸‹) */
    width: 100%;
    overflow: hidden;
}
.chart-body.layout-right {
    flex-direction: row; /* å³å´é…ç½®: æ¨ªä¸¦ã³ */
    align-items: stretch;
}

/* åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆå‡¡ä¾‹ãŒä¸‹ã«ã‚ã‚‹å ´åˆç”¨ï¼‰ */
.chart-canvas-wrapper {
    flex-grow: 1;
    position: relative;
    width: 100%;   /* â˜…ç¸¦ä¸¦ã³ã®ã¨ãã¯å¹…100%ãŒå¿…è¦ */
    min-width: 0;
    min-height: 0;
    padding: 10px;
}

/* å‡¡ä¾‹ãŒå³å´ã«ã‚ã‚‹å ´åˆã®ä¸Šæ›¸ãã‚¹ã‚¿ã‚¤ãƒ« */
.chart-body.layout-right .chart-canvas-wrapper {
    width: 0;      /* â˜…æ¨ªä¸¦ã³ã®ã¨ãã¯å¹…0ã«ã—ã¦flex-growã«è¨ˆç®—ã•ã›ã‚‹ */
}

/* â˜…â˜…â˜… è‡ªä½œå‡¡ä¾‹ã‚¨ãƒªã‚¢ã®ã‚¹ã‚¿ã‚¤ãƒ« â˜…â˜…â˜… */
.custom-legend-container {
    overflow-y: auto;
    background: #fff;
    padding: 5px 10px;
    flex-shrink: 0; /* ã‚°ãƒ©ãƒ•ã«æŠ¼ã—ã¤ã¶ã•ã‚Œãªã„ã‚ˆã†ã« */
}

/* [ä¸‹å´] å‡¡ä¾‹ã‚¹ã‚¿ã‚¤ãƒ« */
.chart-body:not(.layout-right) .custom-legend-container {
    height: 100px; /* å›ºå®šé«˜ã• */
    width: 100%;
    border-top: 1px solid #e5e7eb;
    display: flex;
    flex-wrap: wrap;
    align-content: flex-start;
    gap: 4px 12px;
}

/* [å³å´] å‡¡ä¾‹ã‚¹ã‚¿ã‚¤ãƒ« */
.chart-body.layout-right .custom-legend-container {
    width: 200px; /* å›ºå®šå¹… */
    height: auto;
    border-left: 1px solid #e5e7eb;
    display: block;
}
/* å³å´æ™‚ã¯ç¸¦ä¸¦ã³ãŒè¦‹ã‚„ã™ã„ */
.chart-body.layout-right .legend-item {
    margin-bottom: 4px;
    display: flex;
    align-items: center;
    width: 100%;
}

/* å‡¡ä¾‹ã‚¢ã‚¤ãƒ†ãƒ å…±é€š */
.legend-item {
    cursor: pointer;
    user-select: none;
    padding: 2px 4px;
    border-radius: 4px;
    transition: background 0.2s;
    color: #333;
    display: flex;
    align-items: center;
}
.legend-item:hover { background-color: #f3f4f6; }
.legend-item.hidden-item { opacity: 0.5; text-decoration: line-through; }
.legend-marker {
    display: inline-block;
    margin-right: 6px;
    border: 1px solid rgba(0,0,0,0.1);
    flex-shrink: 0;
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
@media (max-width: 1200px) {
    .charts-wrapper.cols-2, .charts-wrapper.cols-3,
    .composition-wrapper.cols-2 {
        grid-template-columns: 1fr !important;
    }
}

.table-container { overflow-x: auto; }
table { width: 100%; border-collapse: collapse; font-size: 13px; }
th { background: #3b82f6; color: white; padding: 10px 8px; text-align: left; font-weight: 600; border: 1px solid #2563eb; white-space: nowrap; }
td { padding: 0; border: 1px solid #d1d5db; vertical-align: middle; }
input[type="text"], input[type="number"] { width: 100%; border: none; padding: 8px; font-size: 13px; outline: none; background: transparent; }
input[type="color"] { width: 100%; height: 38px; border: none; padding: 4px; background: transparent; }
textarea.data-editor { width: 100%; height: 100px; border: none; padding: 8px; font-family: monospace; font-size: 12px; resize: vertical; outline: none; white-space: pre; overflow-y: auto; }
button, .btn-file { padding: 8px 16px; border-radius: 6px; border: none; cursor: pointer; font-weight: 500; transition: 0.2s; display: inline-flex; justify-content: center; align-items: center; text-align: center; white-space: nowrap; }
.btn-add { background: #3b82f6; color: white; }
.btn-del { background: #ef4444; color: white; }
.btn-export { background: #10b981; color: white; }
.btn-import { background: #f59e0b; color: white; }
.btn-download { font-size: 12px; padding: 4px 8px; background: #6b7280; color: white; }
.help-text { font-size: 12px; color: #6b7280; margin: 4px 0 12px 0; }
.file-input { display: none; }

/* ã‚¿ãƒ– */
.tabs { border-bottom: 2px solid #2c3e50; margin-bottom: 10px; display: flex; gap: 4px; }
.tab-link { background: #bdc3c7; padding: 8px 20px; cursor: pointer; font-size: 13px; font-weight: bold; color: #2c3e50; border: 1px solid #95a5a6; border-bottom: none; border-radius: 4px 4px 0 0; min-width: 100px; text-align: center; margin-bottom: 0; }
.tab-link.active { background: #2c3e50; color: #fff; border-color: #2c3e50; }
.tab-content { display: none; height: auto; padding-bottom: 20px; }

/* ãƒ¢ãƒ¼ãƒ€ãƒ«å…±é€š */
.modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.6); z-index: 1000; display: none; align-items: center; justify-content: center; }
.modal-content { background: white; border-radius: 8px; width: 95%; max-width: 1200px; height: 90vh; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 10px 25px rgba(0,0,0,0.3); }
.modal-header { padding: 16px; border-bottom: 1px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center; background: #f8f9fa; }
.modal-header h3 { font-size: 18px; margin: 0; }
.modal-header .close-btn { font-size: 24px; cursor: pointer; border: none; background: none; }
.modal-body { flex-grow: 1; padding: 16px; overflow-y: auto; }
.modal-footer { padding: 16px; border-top: 1px solid #e5e7eb; text-align: right; flex-shrink: 0; background: #f8f9fa; display: flex; justify-content: flex-end; gap: 10px; }

/* å„ç¨®ãƒ¢ãƒ¼ãƒ€ãƒ«å†…èª¿æ•´ */
.modal-body-split { display: grid; grid-template-columns: 320px 1fr; gap: 16px; height: 100%; overflow: hidden; }
.modal-body-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; height: 100%; overflow: hidden; }
.processor-col { display: flex; flex-direction: column; overflow: hidden; height: 100%; }
.handsontable-container { flex-grow: 1; overflow: hidden; border: 1px solid #ccc; }
.canvas-panel { border: 1px solid #d1d5db; border-radius: 8px; background: #f9fafb; padding: 16px; overflow: auto; display: flex; align-items: center; justify-content: center; height: 100%; }
.controls-panel { display: flex; flex-direction: column; gap: 12px; overflow-y: auto; }

/* æŠ½å‡ºãƒ„ãƒ¼ãƒ«ç”¨ */
.instruction-box { background: #eff6ff; border-left: 4px solid #3b82f6; padding: 12px; border-radius: 4px; }
.input-group { margin-bottom: 8px; }
.input-group label { display: block; font-size: 13px; font-weight: 500; margin-bottom: 4px; }
.input-group input { width: 100%; padding: 6px 10px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; }
.curve-btn { flex-grow: 1; background: #e5e7eb; color: #374151; }
.curve-btn.active { background: #3b82f6; color: white; font-weight: bold; }
.final-actions { border-top: 1px solid #e5e7eb; padding-top: 12px; display: flex; flex-direction: column; gap: 8px; }
.hidden { display: none; }

/* åŸºæº–ç¯„å›²ãƒ†ãƒ¼ãƒ–ãƒ« */
.accordion-group { border: 1px solid #d1d5db; border-radius: 8px; margin-bottom: 12px; overflow: hidden; background-color: white; }
.accordion-header { background-color: #f9fafb; padding: 10px 15px; cursor: pointer; display: flex; align-items: center; gap: 10px; }
.accordion-header:hover { background-color: #f3f4f6; }
.accordion-header .toggle-icon { font-size: 12px; width: 16px; text-align: center; }
.accordion-header .group-name-input { flex-grow: 1; font-size: 16px; font-weight: bold; border: none; background: transparent; padding: 4px; }
.accordion-header .header-actions { margin-left: auto; }
.accordion-header .header-actions button { font-size: 12px; padding: 4px 8px; min-height: 0; }
.accordion-content { padding: 15px; border-top: 1px solid #d1d5db; display: none; }
.accordion-content.open { display: block; }

/* æ—¢å­˜ãƒ†ãƒ¼ãƒ–ãƒ«èª¿æ•´ */
td.cell-center { text-align: center; }
#dataTable td { padding: 0; }
#dataTable input, #dataTable textarea { padding-top: 2px; padding-bottom: 2px; font-size: 12px; }
#dataTable textarea.data-editor { height: 30px; }
#dataTable .btn-del { min-height: 0; height: 100%; padding: 4px; }

/* ãƒ˜ãƒ«ãƒ—ãƒ¢ãƒ¼ãƒ€ãƒ« */
#helpModal .modal-content, #layerOrderModal .modal-content { max-width: 800px; height: auto; max-height: 85vh; }
#helpModal .modal-body { display: block; padding: 25px; line-height: 1.7; overflow-y: auto;}
#helpModal h4 { font-size: 1.1em; margin-top: 20px; margin-bottom: 8px; padding-bottom: 5px; border-bottom: 2px solid #3b82f6; }
#helpModal ul { margin-left: 20px; margin-bottom: 10px; }
#layerOrderList { list-style-type: none; padding: 0; }
#layerOrderList li { padding: 12px; margin-bottom: 8px; background-color: #f9fafb; border: 1px solid #d1d5db; border-radius: 6px; cursor: grab; display: flex; align-items: center; gap: 10px; font-weight: 500; }
#layerOrderList li.dragging { opacity: 0.5; background: #e0f2fe; }

#locationFilterContainer { display: flex; flex-wrap: wrap; align-items: center; gap: 15px; padding: 10px; background-color: #f9fafb; border-radius: 6px; margin-bottom: 16px; border: 1px solid #e5e7eb; }
    </style>
</head>
<body>
    <!-- å·¦ã‚µã‚¤ãƒ‰ãƒãƒ¼ -->
    <div id="sidebar" class="sidebar">
        <div class="sidebar-title">
            <span>ğŸ“Š ç²’åº¦è©¦é¨“çµæœæ•´ç†ã‚·ã‚¹ãƒ†ãƒ </span>
            <button id="helpButton" class="help-icon" title="ãƒ˜ãƒ«ãƒ—">?</button>
        </div>

        <div class="sidebar-panel">
            <h3>ãƒ‡ãƒ¼ã‚¿æ“ä½œ</h3>
            <div class="btn-group">
                <button class="btn-sidebar btn-green" onclick="saveAppState()">ğŸ’¾ ä¿å­˜</button>
                <label for="appStateFileInput" class="btn-sidebar btn-orange" style="margin-bottom:0; cursor:pointer;">ğŸ“‚ èª­è¾¼</label>
                <input type="file" id="appStateFileInput" class="file-input" accept=".json" onchange="handleAppStateImport(event)" style="display: none;">
            </div>
            <button class="btn-sidebar btn-blue" style="width:100%; margin-top:5px;" onclick="openInputModal()">âœï¸ ãƒ‡ãƒ¼ã‚¿ç·¨é›†</button>
        </div>

        <!-- ã‚°ãƒ©ãƒ•è¨­å®šãƒ‘ãƒãƒ« (ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ã‚ªãƒ³) -->
        <div class="sidebar-panel">
            <h3 class="collapsible-header" onclick="toggleSidebarPanel('panel-display-settings', 'arrow-display')">
                ã‚°ãƒ©ãƒ•è¡¨ç¤ºè¨­å®š
                <span id="arrow-display" class="arrow-icon">â–¼</span>
            </h3>
            <div id="panel-display-settings">
                <label class="toggle"><input type="checkbox" id="gridToggle" checked onchange="updateAllChartOptions()"> ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º</label>
                <label class="toggle"><input type="checkbox" id="soilBgToggle" checked onchange="updateAllChartOptions()"> åœŸè³ªèƒŒæ™¯ç€è‰²</label>
                <label class="toggle"><input type="checkbox" id="markerToggle" checked onchange="renderGradationCharts()"> ãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤º</label>
                <label class="toggle"><input type="checkbox" id="dataLabelsToggle" onchange="updateAllChartOptions()"> ãƒ‡ãƒ¼ã‚¿ãƒ©ãƒ™ãƒ«</label>
                <div class="control-item">
                    <span class="control-label">ã‚°ãƒ©ãƒ•ã®é«˜ã• (px)</span>
                    <input type="number" id="chartHeightInput" value="500" step="50" class="dark-input" onchange="updateAllChartOptions()">
                </div>
                <!-- â˜…åˆ—æ•°è¨­å®šã‚’è¿½åŠ  -->
                <div class="control-item">
                    <span class="control-label">ä¸¦ã³ (åˆ—æ•°)</span>
                    <select id="chartColumnsInput" class="dark-input" onchange="updateChartLayout()">
                        <option value="1" selected>1åˆ— (æ¨™æº–)</option>
                        <option value="2">2åˆ—</option>
                        <option value="3">3åˆ—</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="sidebar-panel">
            <h3 class="collapsible-header" onclick="toggleSidebarPanel('panel-group-settings', 'arrow-group')">
                åŸºæº–ãƒ»ã‚°ãƒ«ãƒ¼ãƒ—
                <span id="arrow-group" class="arrow-icon">â–¶</span>
            </h3>
            <div id="panel-group-settings" style="display:none;">
                <div class="control-item">
                    <span class="control-label">ã‚°ãƒ©ãƒ•åŒ–ã®å˜ä½</span>
                    <select id="groupingCriteria" class="dark-input" onchange="renderGradationCharts()">
                        <option value="layer" selected>åœŸå±¤</option>
                        <option value="location">åœ°ç‚¹å</option>
                        <option value="soilType">åœŸè³ªå</option>
                        <option value="all">ã™ã¹ã¦çµ±åˆ</option>
                        <option value="each">è©¦æ–™ã”ã¨</option>
                    </select>
                </div>
                <label class="toggle" style="margin-top: 8px; border-top: 1px solid #555; padding-top: 8px; margin-bottom: 8px;">
                    <input type="checkbox" id="splitByUcToggle" onchange="renderGradationCharts()"> Uc=3.5ã§ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç´°åˆ†åŒ–
                </label>

                <div class="control-item">
                    <span class="control-label">åŸºæº–ç¯„å›²ã®è¡¨ç¤º(å…¨ä½“)</span>
                    <select id="standardGroupSelector" class="dark-input" onchange="renderGradationCharts()"></select>
                </div>
                <button class="btn-sidebar btn-gray" style="width:100%;" onclick="openLayerOrderModal()">åœŸå±¤ç•ªå·ã®è‡ªå‹•å‰²å½“</button>
                <button class="btn-sidebar btn-purple" style="width:100%; margin-top:5px;" onclick="openSortOrderModal()">â‡… ã‚°ãƒ«ãƒ¼ãƒ—ãƒ»åœŸå±¤ã®ä¸¦ã³æ›¿ãˆ</button>
            </div>
        </div>

        <div class="sidebar-panel">
            <h3 class="collapsible-header" onclick="toggleSidebarPanel('panel-legend-settings', 'arrow-legend')">
                å‡¡ä¾‹ã®è¨­å®š
                <span id="arrow-legend" class="arrow-icon">â–¶</span>
            </h3>
            <div id="panel-legend-settings" style="display:none;">
                <div style="margin-bottom:8px;">
                    <span class="control-label">è¡¨ç¤ºé …ç›®:</span>
                    <label class="toggle"><input type="checkbox" class="legend-option" value="location" checked onchange="renderGradationCharts()"> åœ°ç‚¹å</label>
                    <label class="toggle"><input type="checkbox" class="legend-option" value="name" checked onchange="renderGradationCharts()"> è©¦æ–™å</label>
                    <label class="toggle"><input type="checkbox" class="legend-option" value="depth" checked onchange="renderGradationCharts()"> æ·±åº¦</label>
                    <label class="toggle"><input type="checkbox" class="legend-option" value="soilType" onchange="renderGradationCharts()"> åœŸè³ªå</label>
                </div>
                <!-- å‡¡ä¾‹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆåˆ‡ã‚Šæ›¿ãˆ -->
                <label class="toggle" style="border-top:1px solid #555; padding-top:5px;">
                    <input type="checkbox" id="legendStyleToggle" onchange="renderGradationCharts()"> å‡¡ä¾‹ã‚’å³å´ã«è¡¨ç¤º
                </label>
                <!-- å‡¡ä¾‹ã‚µã‚¤ã‚ºè¨­å®š (è‡ªä½œå‡¡ä¾‹ç”¨) -->
                <div style="display:flex; gap:10px; margin-top:5px;">
                    <div style="flex:1;">
                        <span class="control-label">æ–‡å­—ã‚µã‚¤ã‚º</span>
                        <input type="number" id="legendFontSize" value="12" min="8" max="24" class="dark-input" onchange="renderGradationCharts()">
                    </div>
                    <div style="flex:1;">
                        <span class="control-label">ãƒãƒ¼ã‚«ãƒ¼</span>
                        <input type="number" id="legendMarkerSize" value="12" min="8" max="30" class="dark-input" onchange="renderGradationCharts()">
                    </div>
                </div>
            </div>
        </div>

        <div class="sidebar-panel">
            <h3 class="collapsible-header" onclick="toggleSidebarPanel('panel-export', 'arrow-export')">
                ç”»åƒãƒ»å‡ºåŠ›
                <span id="arrow-export" class="arrow-icon">â–¶</span>
            </h3>
            <div id="panel-export" style="display:none;">
                <div class="control-item">
                    <span class="control-label">ç”»åƒè§£åƒåº¦</span>
                    <select id="pngResolution" class="dark-input">
                        <option value="1">æ¨™æº– (1x)</option>
                        <option value="2" selected>é«˜è§£åƒåº¦ (2x)</option>
                        <option value="3">æœ€é«˜è§£åƒåº¦ (3x)</option>
                    </select>
                </div>
                <div class="control-item">
                    <span class="control-label">ç”»åƒå½¢å¼</span>
                    <select id="imageFormat" class="dark-input">
                        <option value="png" selected>PNG</option>
                        <option value="jpeg">JPG</option>
                    </select>
                </div>
                <div class="btn-group">
                    <button class="btn-sidebar btn-purple" onclick="exportToPowerPoint()">PPTXå‡ºåŠ›</button>
                    <button class="btn-sidebar btn-green" onclick="downloadAllChartsAsZip()">ZIPä¿å­˜</button>
                </div>
            </div>
        </div>
    </div>

    <!-- ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ -->
    <div id="main-content">
        <div class="tabs">
            <button class="tab-link active" onclick="openTab(event, 'GradationCurve')">ğŸ“ˆç²’å¾„åŠ ç©æ›²ç·š</button>
            <button class="tab-link" onclick="openTab(event, 'ReferenceStandards')">ğŸ›ï¸åŸºæº–ç¯„å›²ã®è¨­å®š</button>
            <button class="tab-link" onclick="openTab(event, 'Composition')">ğŸ§®ç²’åº¦æ§‹æˆ</button>
        </div>

        <div id="GradationCurve" class="tab-content" style="display:block;">
            <div id="locationFilterContainer"></div>
            <div class="charts-wrapper" id="chartsContainer"></div>
        </div>

        <div id="ReferenceStandards" class="tab-content">
            <h2 style="margin-top:10px;">èƒŒæ™¯ã«è¡¨ç¤ºã™ã‚‹åŸºæº–ç¯„å›²ã®è¨­å®š</h2>
            <div id="standardsContainer"></div>
            <div style="margin-top: 12px; display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn-add" onclick="addNewGroup()">ï¼‹ æ–°è¦ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿½åŠ </button>
                <button class="btn-export" onclick="exportStandards()">è¨­å®šã‚’ä¿å­˜ (.json)</button>
                <label for="standardsFileInput" class="btn-file btn-import">è¨­å®šã‚’èª­è¾¼ (.json)</label>
                <input type="file" id="standardsFileInput" class="file-input" accept=".json" onchange="handleStandardsImport(event)">
            </div>
        </div>

        <div id="Composition" class="tab-content">
            <div class="controls" style="flex-direction: column; align-items: flex-start; gap: 12px; margin-top:10px;">
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <label for="compositionDisplayMode">è¡¨ç¤ºæ–¹æ³•:</label>
                    <select id="compositionDisplayMode" onchange="renderCompositionChart()">
                        <option value="grouped">åœŸå±¤ã”ã¨ã«è¡¨ç¤º</option>
                        <option value="all">å…¨ä½“ã‚’çµ±åˆã—ã¦è¡¨ç¤º</option>
                    </select>

                    <label for="compositionColumns" style="margin-left: 10px;">ä¸¦ã³:</label>
                    <select id="compositionColumns" onchange="updateCompositionLayout()">
                        <option value="1" selected>1åˆ— (ãƒ¯ã‚¤ãƒ‰)</option>
                        <option value="2">2åˆ— (ã‚°ãƒªãƒƒãƒ‰)</option>
                    </select>
                    
                    <label for="sortOrder" style="margin-left: 10px;">ä¸¦ã¹æ›¿ãˆ:</label>
                    <select id="sortOrder" onchange="renderCompositionChart()">
                        <option value="default">å…¥åŠ›é †</option>
                        <option value="depth">æ·±åº¦é † (æµ…ã„é †)</option>
                        <option value="layer">åœŸå±¤é †</option>
                        <option value="location">åœ°ç‚¹ã”ã¨</option>
                    </select>
                    <label for="interpolationMethod" style="margin-left: 10px;">è£œé–“æ–¹æ³•:</label>
                    <select id="interpolationMethod" onchange="renderCompositionChart()">
                        <option value="logarithmic" selected>æ›²ç·šè£œé–“(å¯¾æ•°)</option>
                        <option value="linear">ç›´ç·šè£œé–“</option>
                    </select>
                </div>
                <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; padding-top: 10px; border-top: 1px solid #e5e7eb; width: 100%;">
                    <span style="font-weight: 500;">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ:</span>
                    <button class="btn-export" style="background-color: #6d28d9;" onclick="exportCompositionToPowerPoint()">ğŸ“¤ PPTXå‡ºåŠ›</button>
                    <button class="btn-export" style="background-color: #059669;" onclick="downloadAllCompositionChartsAsZip()">ğŸï¸ ZIPä¸€æ‹¬ä¿å­˜</button>
                    <p class="help-text" style="margin: 0 0 0 10px;">â€»ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‚°ãƒ©ãƒ•ãŒã™ã¹ã¦å‡ºåŠ›ã•ã‚Œã¾ã™ã€‚</p>
                </div>
            </div>
            <div class="composition-wrapper" id="compositionContainer"></div>
        </div>

        <!-- ãƒ•ãƒƒã‚¿ãƒ¼ -->
        <footer style="font-size: 12px; text-align: center; padding: 20px; color: #6c757d; background-color: #f8f9fa; border-top: 1px solid #e9ecef; margin-top: auto;">
            <div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap; margin-bottom: 10px;">
                <p id="lastUpdated" style="margin: 0; font-weight: 500;"></p>
                <button id="legal-toggle" style="background: none; border: none; cursor: pointer; font-weight: bold; color: #4b5563; text-decoration: underline; padding: 5px;">
                    å…è²¬äº‹é … (ã‚¯ãƒªãƒƒã‚¯ã§è¡¨ç¤º)
                </button>
            </div>
        
            <div id="legal-details" style="display: none; margin-top: 15px; border-top: 1px solid #d1d5db; padding-top: 15px; text-align: left; max-width: 800px; margin-left: auto; margin-right: auto; line-height: 1.6;">
                <p style="text-align: center; font-weight: bold; margin-bottom: 5px; color: #374151;">
                    Copyright &copy; 2025 (æ ª)åœ°åœç·åˆã‚³ãƒ³ã‚µãƒ«ã‚¿ãƒ³ãƒˆ All Rights Reserved.
                </p>
                <p style="font-size: 11px; color: #6b7280; text-align: center; margin-bottom: 15px;">
                    Developed by: Naoya.Onozato
                </p>
                
                <div style="background-color: #fff7ed; border: 1px solid #fdba74; color: #c2410c; padding: 10px; border-radius: 6px; margin-bottom: 15px; font-weight: bold; text-align: center;">
                    âš  æœ¬ã‚·ã‚¹ãƒ†ãƒ ã®å†é…å¸ƒãƒ»ç¬¬ä¸‰è€…ã¸ã®æä¾›ã‚’ç¦æ­¢ã—ã¾ã™ã€‚
                </div>
        
                <div style="font-size: 11px; color: #4b5563;">
                    <p style="margin-bottom: 10px;">
                        <strong>ã€å…è²¬äº‹é …ã€‘</strong><br>
                        æœ¬ã‚·ã‚¹ãƒ†ãƒ ã®åˆ©ç”¨ã«ã‚ˆã£ã¦ç”Ÿã˜ãŸã„ã‹ãªã‚‹æå®³ã«ã¤ã„ã¦ã‚‚ã€é–‹ç™ºè€…ãŠã‚ˆã³è‘—ä½œæ¨©è€…ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã¾ã›ã‚“ã€‚æœ¬ãƒ„ãƒ¼ãƒ«ã¯ã‚ãã¾ã§æ¥­å‹™è£œåŠ©ã‚’ç›®çš„ã¨ã—ãŸã‚‚ã®ã§ã‚ã‚Šã€å‡ºåŠ›ã•ã‚Œã‚‹è¨ˆç®—çµæœã‚„ã‚°ãƒ©ãƒ•ã¯ã€å¿…ãšå°‚é–€æŠ€è¡“è€…ãŒç¢ºèªãƒ»æ¤œè¨¼ã—ãŸä¸Šã§ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚æœ¬ã‚·ã‚¹ãƒ†ãƒ ãŒå‡ºåŠ›ã™ã‚‹å€¤ã®æ­£ç¢ºæ€§ã‚„å®Œå…¨æ€§ã‚’ä¿è¨¼ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
                    </p>
                    <p style="margin-bottom: 0;">
                        <strong>ã€ä½¿ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã€‘</strong><br>
                        Chart.js, Handsontable, chartjs-plugin-datalabels, PptxGenJS, JSZip
                    </p>
                </div>
            </div>
        </footer>
    </div>

    <!-- ãƒ‡ãƒ¼ã‚¿å…¥åŠ›ç”¨ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="inputModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>ğŸ“ ãƒ‡ãƒ¼ã‚¿å…¥åŠ›ãƒ»ç·¨é›†</h3>
                <button class="close-btn" onclick="closeInputModal()">&times;</button>
            </div>
            <div class="modal-body" style="display: flex; flex-direction: column;">
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px; margin-bottom: 12px;">
                    <p class="help-text" style="margin:0;">ãƒ‡ãƒ¼ã‚¿ã‚’å…¥åŠ›ãƒ»ç·¨é›†ã—ãŸã‚‰ã€Œé–‰ã˜ã‚‹ã€ã¾ãŸã¯èƒŒæ™¯ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚°ãƒ©ãƒ•ã«åæ˜ ã•ã›ã¦ãã ã•ã„ã€‚</p>
                    <div class="controls" style="margin-bottom: 0; display: flex; flex-wrap: nowrap; gap: 10px;">
                        <button class="btn-add" onclick="addNewRow()">ï¼‹ æ–°è¦è¿½åŠ </button>
                        <button class="btn-del" onclick="deleteSelectedSamples()">ğŸ—‘ï¸é¸æŠå‰Šé™¤</button>
                        <button class="btn-import" style="background-color: #9333ea;" onclick="openDataProcessorModal()">ğŸ“‹Excelå–è¾¼</button>
                        <button class="btn-export" onclick="exportCSV()">ğŸ“¤CSVå‡ºåŠ›</button>
                        <label for="csvFileInput" class="btn-file btn-import">ğŸ“¥CSVèª­è¾¼</label>
                        <input type="file" id="csvFileInput" class="file-input" accept=".csv" onchange="handleCSVImport(event)">
                    </div>
                </div>
                <div class="table-container" style="flex-grow: 1;">
                    <table id="dataTable">
                        <thead>
                            <tr>
                                <th style="width: 30px;"><input type="checkbox" id="selectAllCheckbox" title="ã™ã¹ã¦é¸æŠ/è§£é™¤"></th>
                                <th style="width: 40px;">No.</th>
                                <th style="width: 120px;">åœ°ç‚¹å</th>
                                <th style="width: 120px;">è©¦æ–™å</th>
                                <th style="width: 80px;">æ·±åº¦(m)</th>
                                <th style="width: 80px;">åœŸè³ªå</th>
                                <th style="width: 60px;">åœŸå±¤</th>
                                <th style="width: 180px;">ãƒ‡ãƒ¼ã‚¿ (ç²’å¾„[tab]é€šéç‡)</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody"></tbody>
                    </table>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-add" onclick="closeInputModal()">é–‰ã˜ã‚‹ (ã‚°ãƒ©ãƒ•æ›´æ–°)</button>
            </div>
        </div>
    </div>

    <!-- Excelå–è¾¼ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="dataProcessorModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h3>ğŸ“‹ Excelãƒ‡ãƒ¼ã‚¿æ•´å½¢ãƒ»èª­è¾¼ (ã‚°ãƒªãƒƒãƒ‰å½¢å¼)</h3><button class="close-btn" onclick="closeDataProcessorModal()">&times;</button></div>
            <div class="modal-body" style="padding:0;">
                <div id="processorInputArea" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding:16px;">
                    <div class="modal-body-grid">
                        <div class="processor-col"><h4 style="margin-bottom: 8px;">1. è©¦é¨“ä¸€è¦§è¡¨ãƒ‡ãƒ¼ã‚¿</h4><p class="help-text" style="margin-top:0; flex-shrink: 0;">Excelã®ã€Œè©¦é¨“ä¸€è¦§è¡¨ã€ã‹ã‚‰<b>ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’å«ã¾ãªã„</b>ãƒ‡ãƒ¼ã‚¿ç¯„å›²ã‚’ã‚³ãƒ”ãƒ¼ã—ã€ä¸‹ã®è¡¨ã®å·¦ä¸Šã®ã‚»ãƒ«ã‚’é¸æŠã—ã¦è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚</p><div id="listTableContainer" class="handsontable-container"></div></div>
                        <div class="processor-col"><h4 style="margin-bottom: 8px;">2. ç²’åº¦è©¦é¨“çµæœãƒ‡ãƒ¼ã‚¿</h4><p class="help-text" style="margin-top:0; flex-shrink: 0;">Excelã®ã€Œç²’åº¦è©¦é¨“çµæœã€ã‹ã‚‰<b>ãƒ˜ãƒƒãƒ€ãƒ¼ã‚’å«ã¾ãªã„</b>ãƒ‡ãƒ¼ã‚¿ç¯„å›²ã‚’ã‚³ãƒ”ãƒ¼ã—ã€ä¸‹ã®è¡¨ã®å·¦ä¸Šã®ã‚»ãƒ«ã‚’é¸æŠã—ã¦è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ã€‚</p><div id="resultsTableContainer" class="handsontable-container"></div></div>
                    </div>
                    <div style="margin-top:10px; text-align:right;"><button class="btn-export" onclick="processPastedData()">ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’è¡¨ç¤º</button></div>
                </div>
                <div id="processorPreviewArea" style="display: none; flex-direction: column; height: 100%; padding:16px;">
                     <div class="table-container" style="flex-grow: 1; overflow-y: auto;"><p class="help-text" style="margin-top:0;">ä»¥ä¸‹ã®å†…å®¹ã§èª­ã¿è¾¼ã¿ã¾ã™ã€‚å•é¡ŒãŒãªã‘ã‚Œã°ã€Œã“ã®å†…å®¹ã§èª­ã¿è¾¼ã‚€ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚</p><table id="processorPreviewTable"></table></div>
                     <div style="margin-top:10px; display:flex; justify-content:space-between;"><button class="btn-import" onclick="backToInput()">â† å…¥åŠ›ã«æˆ»ã‚‹</button><button class="btn-add" onclick="confirmImport()">ã“ã®å†…å®¹ã§èª­ã¿è¾¼ã‚€</button></div>
                </div>
            </div>
        </div>
    </div>

    <!-- ãã®ä»–ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="imageExtractorModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h3>ğŸ“ˆ ã‚°ãƒ©ãƒ•ç”»åƒã‹ã‚‰ã®æ›²ç·šãƒ‡ãƒ¼ã‚¿æŠ½å‡º</h3><button class="close-btn" onclick="imageExtractor.close()">&times;</button></div>
            <div class="modal-body">
                <div class="modal-body-split">
                    <div class="controls-panel">
                        <div id="extractorUploadArea">
                            <div class="instruction-box"><p>1. ã‚°ãƒ©ãƒ•ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚</p></div>
                            <label for="extractorImageInput" class="btn-file btn-import" style="width: 100%; margin-top: 15px;">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</label>
                            <input type="file" id="extractorImageInput" class="file-input" accept="image/*">
                        </div>
                        <div id="extractorMainArea" class="hidden">
                             <div class="instruction-box"><p id="extractorInstruction"></p></div>
                             <div id="extractorAxisInputArea" class="hidden"><div class="input-group"><label id="extractorAxisLabel" for="extractorAxisInput"></label><input type="number" id="extractorAxisInput"></div></div>
                             <div id="extractorExtractArea" class="hidden"><p class="help-text">æŠ½å‡ºã—ãŸã„æ›²ç·šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ç‚¹ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚</p><div class="btn-group"><button id="upperCurveBtn" class="btn-sm curve-btn active" onclick="imageExtractor.switchCurve(0)">ä¸Šé™ç·š (Upper)</button><button id="lowerCurveBtn" class="btn-sm curve-btn" onclick="imageExtractor.switchCurve(1)">ä¸‹é™ç·š (Lower)</button></div></div>
                             <div class="modal-toolbar" style="margin-top: 15px;"><button id="extractorClearPointsBtn" class="btn-sm btn-del">é¸æŠä¸­ã®æ›²ç·šã®ç‚¹ã‚’ã‚¯ãƒªã‚¢</button><button id="extractorResetBtn" class="btn-sm" style="background: #6b7280; color: white;">ãƒªã‚»ãƒƒãƒˆ</button></div>
                             <div class="final-actions" style="margin-top: auto;"><div style="margin-bottom: 8px; text-align: left;"><label><input type="checkbox" id="extractorCombineFill" checked> å¡—ã‚Šã¤ã¶ã—ç¯„å›²ã¨ã—ã¦çµåˆã™ã‚‹</label><p class="help-text" style="margin: 2px 0 0 20px;">ãƒã‚§ãƒƒã‚¯ã‚’å¤–ã™ã¨ã€ä¸Šé™ã¨ä¸‹é™ãŒç‹¬ç«‹ã—ãŸ2ã¤ã®ç·šã¨ã—ã¦ç™»éŒ²ã•ã‚Œã¾ã™ã€‚</p></div><button id="applyExtractedDataBtn" class="btn-add" disabled>ã“ã®ãƒ‡ãƒ¼ã‚¿ã‚’åæ˜ </button><button id="exportExtractedCSVBtn" class="btn-export" disabled>CSVã¨ã—ã¦ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button></div>
                        </div>
                    </div>
                    <div class="canvas-panel"><canvas id="extractorCanvas"></canvas></div>
                </div>
            </div>
        </div>
    </div>
    <div id="layerOrderModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h3>â†•ï¸ åœŸè³ªåã‹ã‚‰åœŸå±¤ç•ªå·ã‚’å‰²ã‚Šå½“ã¦</h3><button class="close-btn" onclick="closeLayerOrderModal()">&times;</button></div>
            <div class="modal-body"><p class="help-text" style="margin-top:0; margin-bottom: 15px;">ã€ŒåœŸè³ªåã€ã®ãƒªã‚¹ãƒˆã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã§ä¸¦ã³æ›¿ãˆã¦ãã ã•ã„ã€‚<br>ä¿å­˜ã™ã‚‹ã¨ã€ã“ã®<b>åœŸè³ªåã®é †åº</b>ã«åŸºã¥ã„ã¦ã€ãƒ‡ãƒ¼ã‚¿å…¥åŠ›ä¸€è¦§ã®<b>ã€ŒåœŸå±¤ã€åˆ—ãŒç•ªå·(1, 2, 3...)ã§ä¸Šæ›¸ã</b>ã•ã‚Œã¾ã™ã€‚</p><ul id="layerOrderList"></ul></div>
            <div class="modal-footer"><button class="btn-add" onclick="saveLayerOrder()">ã“ã®é †åºã§ç•ªå·ã‚’å‰²ã‚Šå½“ã¦</button></div>
        </div>
    </div>
    
    <!-- ä¸¦ã³æ›¿ãˆè¨­å®šç”¨ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="sortOrderModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 500px; height: 80vh;">
            <div class="modal-header">
                <h3>â‡… è¡¨ç¤ºé †åºã®è¨­å®š</h3>
                <button class="close-btn" onclick="closeSortOrderModal()">&times;</button>
            </div>
            <div class="modal-body" style="display: flex; flex-direction: column;">
                <p class="help-text">ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã§ä¸¦ã¹æ›¿ãˆã¦ãã ã•ã„ã€‚ã‚°ãƒ©ãƒ•ã®è¡¨ç¤ºé †ã«åæ˜ ã•ã‚Œã¾ã™ã€‚</p>
                <div class="tabs" style="margin-bottom: 10px;">
                    <button class="tab-link active" onclick="switchSortTab('layer')" id="tabBtnLayer">åœŸå±¤ (Layer)</button>
                    <button class="tab-link" onclick="switchSortTab('soilType')" id="tabBtnSoil">åœŸè³ªå</button>
                </div>
                <div style="flex-grow: 1; overflow-y: auto; border: 1px solid #d1d5db; border-radius: 4px; padding: 10px; background: #f9fafb;">
                    <ul id="sortOrderList" style="list-style: none; padding: 0;"></ul>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-add" onclick="saveSortOrderSettings()">è¨­å®šã‚’ä¿å­˜ã—ã¦åæ˜ </button>
            </div>
        </div>
    </div>

<!-- ãƒ˜ãƒ«ãƒ—ãƒ¢ãƒ¼ãƒ€ãƒ« -->
    <div id="helpModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header"><h3>â„¹ï¸ ç²’åº¦è©¦é¨“çµæœãƒ»æ•´ç†ã‚·ã‚¹ãƒ†ãƒ  å–æ‰±èª¬æ˜</h3><button class="close-btn">&times;</button></div>
            <div class="modal-body">
                <p>æœ¬ã‚·ã‚¹ãƒ†ãƒ ã¯ã€åœŸè³ªè©¦é¨“ï¼ˆç²’åº¦è©¦é¨“ï¼‰ã®çµæœã‚’å…¥åŠ›ã—ã€ã€Œç²’å¾„åŠ ç©æ›²ç·šã€ãŠã‚ˆã³ã€Œç²’åº¦æ§‹æˆã‚°ãƒ©ãƒ•ã€ã‚’åŠ¹ç‡çš„ã«ä½œæˆãƒ»æ•´ç†ã™ã‚‹ãŸã‚ã®ãƒ„ãƒ¼ãƒ«ã§ã™ã€‚</p>
                <hr style="margin: 15px 0; border: 0; border-top: 1px solid #eee;">

                <h4>1. ãƒ‡ãƒ¼ã‚¿ã®å…¥åŠ›æ–¹æ³•</h4>
                <ul>
                    <li><strong>ãƒ‡ãƒ¼ã‚¿ç·¨é›†ç”»é¢:</strong> ã‚µã‚¤ãƒ‰ãƒãƒ¼ã® <code>[âœï¸ ãƒ‡ãƒ¼ã‚¿ç·¨é›†]</code> ãƒœã‚¿ãƒ³ã‹ã‚‰é–‹ãã¾ã™ã€‚</li>
                    <li><strong>Excelã‹ã‚‰ã®ä¸€æ‹¬å–è¾¼:</strong> ç·¨é›†ç”»é¢å†…ã® <code>[ğŸ“‹ Excelå–è¾¼]</code> ã‚’æŠ¼ã™ã¨ã€Excelã®ã€Œè©¦é¨“ä¸€è¦§è¡¨ã€ã¨ã€Œç²’åº¦è©¦é¨“çµæœã€ã®ã‚»ãƒ«ç¯„å›²ã‚’ã‚³ãƒ”ãƒ¼ï¼†ãƒšãƒ¼ã‚¹ãƒˆã™ã‚‹ã ã‘ã§ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šè¾¼ã‚ã¾ã™ã€‚</li>
                    <li><strong>CSVå…¥å‡ºåŠ›:</strong> ãƒ‡ãƒ¼ã‚¿ã®ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã‚„ä»–ã®ã‚½ãƒ•ãƒˆã¨ã®é€£æºç”¨ã«CSVå½¢å¼ã§ã®å…¥å‡ºåŠ›ã«å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚</li>
                </ul>

                <h4>2. ã‚°ãƒ©ãƒ•è¡¨ç¤ºã¨å‡¡ä¾‹ï¼ˆã¯ã‚“ã‚Œã„ï¼‰ã®æ©Ÿèƒ½</h4>
                <p style="font-size: 0.95em; color: #444; background: #f3f4f6; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                    <strong>ã€æ–°æ©Ÿèƒ½ã€‘ã‚°ãƒ©ãƒ•ã‚µã‚¤ã‚ºã®å›ºå®šåŒ–ã«ã¤ã„ã¦</strong><br>
                    æœ¬ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚ˆã‚Šã€ãƒ‡ãƒ¼ã‚¿ç‚¹æ•°ãŒå¤šã„å ´åˆã§ã‚‚ã‚°ãƒ©ãƒ•æœ¬ä½“ï¼ˆæç”»ã‚¨ãƒªã‚¢ï¼‰ãŒå°ã•ããªã‚‰ãªã„ã‚ˆã†ã€<b>å‡¡ä¾‹ã‚’ã‚°ãƒ©ãƒ•ã®å¤–å´ã«ç‹¬ç«‹</b>ã•ã›ã¾ã—ãŸã€‚
                </p>
                <ul>
                    <li><strong>ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®åˆ‡æ›¿:</strong> ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ã€Œå‡¡ä¾‹ã®è¨­å®šã€ã«ã‚ã‚‹ <code>[å‡¡ä¾‹ã‚’å³å´ã«è¡¨ç¤º]</code> ã®ãƒã‚§ãƒƒã‚¯ã§åˆ‡ã‚Šæ›¿ãˆã¾ã™ã€‚
                        <ul>
                            <li><b>OFF (ä¸‹å´è¡¨ç¤º):</b> ã‚°ãƒ©ãƒ•ã®ä¸‹ã«å‡¡ä¾‹ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚é«˜ã•ã¯å›ºå®šã•ã‚Œã€é …ç›®ãŒå¤šã„å ´åˆã¯ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</li>
                            <li><b>ON (å³å´è¡¨ç¤º):</b> ã‚°ãƒ©ãƒ•ã®å³æ¨ªã«å‡¡ä¾‹ã‚’è¡¨ç¤ºã—ã¾ã™ã€‚æ¨ªå¹…ãŒç¢ºä¿ã•ã‚Œã€ç¸¦ã«é•·ã„ãƒªã‚¹ãƒˆã¨ã—ã¦è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</li>
                        </ul>
                    </li>
                    <li><strong>ã‚µã‚¤ã‚ºèª¿æ•´:</strong> ã‚µã‚¤ãƒ‰ãƒãƒ¼ã§ã€Œæ–‡å­—ã‚µã‚¤ã‚ºã€ã‚„ã€Œãƒãƒ¼ã‚«ãƒ¼ã‚µã‚¤ã‚ºã€ã‚’å¤‰æ›´ã™ã‚‹ã¨ã€å‡¡ä¾‹ã®ãƒ‡ã‚¶ã‚¤ãƒ³ã«å³åº§ã«åæ˜ ã•ã‚Œã¾ã™ã€‚</li>
                    <li><strong>è¡¨ç¤º/éè¡¨ç¤º:</strong> å‡¡ä¾‹ã®é …ç›®åã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€å¯¾å¿œã™ã‚‹ã‚°ãƒ©ãƒ•ç·šã®è¡¨ç¤º/éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã¾ã™ï¼ˆé™¤å¤–ã•ã‚ŒãŸç·šã¯æ‰“ã¡æ¶ˆã—ç·šã§è¡¨ç¤ºã•ã‚Œã¾ã™ï¼‰ã€‚</li>
                    <li><strong>ã‚°ãƒ©ãƒ•åŒ–ã®å˜ä½:</strong> ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®ã€ŒåŸºæº–ãƒ»ã‚°ãƒ«ãƒ¼ãƒ—ã€ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã§ã€ã‚°ãƒ©ãƒ•ã‚’ã¾ã¨ã‚ã‚‹å˜ä½ï¼ˆåœŸå±¤ã”ã¨ã€åœ°ç‚¹ã”ã¨ã€åœŸè³ªåã”ã¨ç­‰ï¼‰ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‰ã‚Œã¾ã™ã€‚</li>
                </ul>

                <h4>3. ç²’åº¦æ§‹æˆã‚°ãƒ©ãƒ•ã®æ©Ÿèƒ½</h4>
                <ul>
                    <li><strong>è¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ã®åˆ‡æ›¿:</strong>
                        <ul>
                            <li><b>ã€ŒåœŸå±¤ã”ã¨ã«è¡¨ç¤ºã€:</b> åœŸå±¤ï¼ˆAc1, As1ãªã©ï¼‰ã”ã¨ã«ã‚°ãƒ©ãƒ•ã‚’åˆ†ã‘ã¦ä½œæˆã—ã¾ã™ã€‚</li>
                            <li><b>ã€Œå…¨ä½“ã‚’çµ±åˆã—ã¦è¡¨ç¤ºã€:</b> å…¨åœ°ç‚¹ãƒ»å…¨æ·±åº¦ã®ãƒ‡ãƒ¼ã‚¿ã‚’1ã¤ã®å¤§ããªã‚°ãƒ©ãƒ•ã«ã¾ã¨ã‚ã¾ã™ã€‚</li>
                        </ul>
                    </li>
                    <li><strong>è£œé–“æ–¹æ³•:</strong> æ§‹æˆç‡ã‚’ç®—å‡ºã™ã‚‹éš›ã€ãƒ‡ãƒ¼ã‚¿ç‚¹é–“ã‚’ã€Œå¯¾æ•°è£œé–“ï¼ˆæ›²ç·šçš„ï¼‰ã€ã™ã‚‹ã‹ã€Œç›´ç·šè£œé–“ã€ã™ã‚‹ã‹ã‚’é¸ã¹ã¾ã™ï¼ˆé€šå¸¸ã¯å¯¾æ•°æ¨å¥¨ï¼‰ã€‚</li>
                </ul>

                <h4>4. é«˜åº¦ãªæ•´ç†æ©Ÿèƒ½</h4>
                <ul>
                    <li><strong>åœŸå±¤ç•ªå·ã®è‡ªå‹•å‰²å½“:</strong> ã‚µã‚¤ãƒ‰ãƒãƒ¼ã® <code>[åœŸå±¤ç•ªå·ã®è‡ªå‹•å‰²å½“]</code> ãƒœã‚¿ãƒ³ã§ã€åœŸè³ªåã®ãƒªã‚¹ãƒˆã‚’ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—ã§ä¸¦ã¹æ›¿ãˆã€ãã®é †åºã«å¾“ã£ã¦ãƒ‡ãƒ¼ã‚¿ã«ã€Œ1, 2, 3...ã€ã¨ç•ªå·ã‚’æŒ¯ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚</li>
                    <li><strong>è¡¨ç¤ºé †åºã®å¤‰æ›´:</strong> <code>[â‡… ã‚°ãƒ«ãƒ¼ãƒ—ãƒ»åœŸå±¤ã®ä¸¦ã³æ›¿ãˆ]</code> ãƒœã‚¿ãƒ³ã§ã€ã‚°ãƒ©ãƒ•ã®è¡¨ç¤ºé †åºï¼ˆå‡¡ä¾‹é †åºï¼‰ã‚’è‡ªç”±ã«ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã§ãã¾ã™ã€‚</li>
                    <li><strong>ç”»åƒã‹ã‚‰ã®æ›²ç·šæŠ½å‡º:</strong> ã€ŒåŸºæº–ç¯„å›²ã®è¨­å®šã€ã‚¿ãƒ–ã«ã¦ã€æ—¢å­˜ã®æ–‡çŒ®ã‚„æŒ‡é‡ã®ã‚°ãƒ©ãƒ•ç”»åƒã‚’èª­ã¿è¾¼ã¿ã€ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã ã‘ã§åº§æ¨™ãƒ‡ãƒ¼ã‚¿ï¼ˆç²’å¾„ãƒ»é€šéç‡ï¼‰ã‚’æŠ½å‡ºãƒ»ç™»éŒ²ã§ãã¾ã™ã€‚</li>
                </ul>

                <h4>5. ä¿å­˜ãƒ»å‡ºåŠ›</h4>
                <ul>
                    <li><strong>ä½œæ¥­çŠ¶æ…‹ã®ä¿å­˜:</strong> ã‚µã‚¤ãƒ‰ãƒãƒ¼ä¸Šéƒ¨ã® <code>[ğŸ’¾ ä¿å­˜]</code> ãƒœã‚¿ãƒ³ã§ã€å…¥åŠ›ãƒ‡ãƒ¼ã‚¿ãƒ»åŸºæº–è¨­å®šãƒ»ä¸¦ã³é †è¨­å®šã‚’ã¾ã‚‹ã”ã¨JSONãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ã§ãã¾ã™ã€‚å†é–‹æ™‚ã¯ <code>[ğŸ“‚ èª­è¾¼]</code> ã‹ã‚‰å¾©å…ƒã—ã¾ã™ã€‚</li>
                    <li><strong>ç”»åƒ/PPTXå‡ºåŠ›:</strong>
                        <ul>
                            <li>å„ã‚°ãƒ©ãƒ•å³ä¸Šã® <code>[ğŸ“· ä¿å­˜]</code> ã§å€‹åˆ¥ã«ç”»åƒä¿å­˜ã€‚</li>
                            <li>ã‚µã‚¤ãƒ‰ãƒãƒ¼ã¾ãŸã¯ã‚¿ãƒ–å†…ã® <code>[PPTXå‡ºåŠ›]</code> ã§ã€è¡¨ç¤ºä¸­ã®å…¨ã‚°ãƒ©ãƒ•ã‚’PowerPointã‚¹ãƒ©ã‚¤ãƒ‰ã¨ã—ã¦ä¸€æ‹¬å‡ºåŠ›ã€‚</li>
                            <li><code>[ZIPä¿å­˜]</code> ã§å…¨ã‚°ãƒ©ãƒ•ã®ç”»åƒã‚’ä¸€æ‹¬ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã€‚</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>
    </div>

<script>
// ã‚µã‚¤ãƒ‰ãƒãƒ¼é–‹é–‰
function toggleSidebarPanel(contentId, arrowId) {
    const content = document.getElementById(contentId);
    const arrow = document.getElementById(arrowId);
    if (content.style.display === 'none') {
        content.style.display = 'block';
        arrow.innerHTML = 'â–¼';
    } else {
        content.style.display = 'none';
        arrow.innerHTML = 'â–¶';
    }
}

// ãƒ‡ãƒ¼ã‚¿å…¥åŠ›ãƒ¢ãƒ¼ãƒ€ãƒ«åˆ¶å¾¡
function openInputModal() {
    document.getElementById('inputModal').style.display = 'flex';
}
function closeInputModal() {
    document.getElementById('inputModal').style.display = 'none';
    renderAllCharts(); // é–‰ã˜ã‚‹æ™‚ã«ã‚°ãƒ©ãƒ•æ›´æ–°
}

let samples = [];
let standardGroups = [];
let customLayerOrder = [];
// ã‚«ã‚¹ã‚¿ãƒ ã‚½ãƒ¼ãƒˆã‚ªãƒ¼ãƒ€ãƒ¼ã®ä¿æŒ
let customSortOrders = {
    layer: [],
    soilType: []
};

const colors = ['#e6194b', '#3cb44b', '#ffe119', '#4363d8', '#f58231', '#911eb4', '#46f0f0', '#f032e6', '#bcf60c', '#fabebe', '#008080', '#e6beff', '#9a6324', '#fffac8', '#800000', '#aaffc3', '#808000', '#ffd8b1', '#000075', '#808080'];
const pointStyles = ['circle', 'rect', 'triangle', 'rectRot', 'star', 'cross', 'crossRot'];
let chartInstances = {};
let compositionChart = null;
let compositionChartInstances = {};

const soilClassifications = [
    { name: 'ç²˜åœŸ', min: 0.001, max: 0.005, color: 'rgba(59, 130, 246, 0.2)' },
    { name: 'ã‚·ãƒ«ãƒˆ', min: 0.005, max: 0.075, color: 'rgba(96, 165, 250, 0.2)' },
    { name: 'ç´°ç ‚', min: 0.075, max: 0.425, color: 'rgba(250, 204, 21, 0.2)' },
    { name: 'ç²—ç ‚', min: 0.425, max: 2,    color: 'rgba(251, 146, 60, 0.2)' },
    { name: 'ç´°ç¤«', min: 2,    max: 4.75, color: 'rgba(248, 113, 113, 0.2)' },
    { name: 'ä¸­ç¤«', min: 4.75, max: 19,   color: 'rgba(239, 68, 68, 0.25)' },
    { name: 'ç²—ç¤«', min: 19,   max: 75,   color: 'rgba(220, 38, 38, 0.25)' },
];

const soilClassificationPlugin = {
    id: 'soilClassificationLegend',
    beforeDraw(chart, args, options) {
        const showBackground = options.showBackground;
        const { ctx, chartArea: { top, bottom, left, right }, scales: { x } } = chart;
        const legendTop = 0, legendHeight = options.legendHeight || 30;
        const numberFont = options.numberFont || '11px sans-serif';
        const labelFont = options.labelFont || 'bold 12px sans-serif';
        const textColor = '#000000';
        const lineColor = options.lineColor || '#94a3b8';
        ctx.save();
        ctx.strokeStyle = lineColor; ctx.lineWidth = 1;
        soilClassifications.forEach(classification => {
            const xStart = x.getPixelForValue(classification.min);
            const xEnd = x.getPixelForValue(classification.max);
            const drawXStart = Math.max(xStart, left);
            const drawXEnd = Math.min(xEnd, right);
            const width = drawXEnd - drawXStart;
            if (width <= 0) return;
            if (showBackground) {
                ctx.fillStyle = classification.color;
                ctx.fillRect(drawXStart, top, width, bottom - top);
                ctx.fillStyle = classification.color.replace(/0\.\d+\)/, '0.6)');
                ctx.fillRect(drawXStart, legendTop, width, legendHeight - 1);
            }
            ctx.fillStyle = textColor; ctx.font = labelFont; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(classification.name, drawXStart + width / 2, legendTop + legendHeight / 2);
        });
        const boundaries = [...new Set(soilClassifications.flatMap(s => [s.min, s.max]))].filter(v => v > 0.001 && v < 75);
        boundaries.forEach(boundaryValue => {
            const xPos = x.getPixelForValue(boundaryValue);
            if (xPos < left || xPos > right) return;
            ctx.beginPath(); ctx.moveTo(xPos, legendTop); ctx.lineTo(xPos, legendTop + legendHeight); ctx.stroke();
            ctx.font = numberFont; ctx.textAlign = 'center'; ctx.textBaseline = 'top'; ctx.fillStyle = textColor;
            ctx.fillText(boundaryValue, xPos, legendTop + legendHeight + 2);
        });
        ctx.strokeRect(left, legendTop, right - left, legendHeight - 1);
        ctx.restore();
    }
};

function hexToRgba(hex, alpha) {
    let r=0,g=0,b=0;
    if(hex.length==4){r="0x"+hex[1]+hex[1];g="0x"+hex[2]+hex[2];b="0x"+hex[3]+hex[3];}
    else if(hex.length==7){r="0x"+hex[1]+hex[2];g="0x"+hex[3]+hex[4];b="0x"+hex[5]+hex[6];}
    return`rgba(${+r},${+g},${+b},${alpha})`;
}

const referenceCurvePlugin = {
    id: 'referenceCurvePlugin',
    beforeDatasetsDraw(chart, args, options) {
        const standards = options.standards || [];
        if (standards.length === 0) return;
        const { ctx, scales: { x, y } } = chart;
        ctx.save();
        standards.forEach(standard => {
            if (!standard.visible || !standard.points || standard.points.length < 2) return;
            const points = standard.points;
            ctx.beginPath();
            ctx.moveTo(x.getPixelForValue(points[0].x), y.getPixelForValue(points[0].y));
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(x.getPixelForValue(points[i].x), y.getPixelForValue(points[i].y));
            }
            if (standard.fill) {
                ctx.fillStyle = hexToRgba(standard.color, standard.opacity);
                ctx.closePath();
                ctx.fill();
            } else {
                ctx.strokeStyle = standard.color;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        });
        const standardsWithComments = standards.filter(s => s.visible && s.fill && s.comment && s.points.length > 0);
        if (standardsWithComments.length > 0) {
            const commentPositions = [];
            const fontSize = 12;
            standardsWithComments.forEach(standard => {
                const pixelPoints = standard.points.map(p => ({ px: x.getPixelForValue(p.x), py: y.getPixelForValue(p.y) }));
                const minPx = Math.min(...pixelPoints.map(p => p.px));
                const maxPx = Math.max(...pixelPoints.map(p => p.px));
                const minPy = Math.min(...pixelPoints.map(p => p.py));
                const maxPy = Math.max(...pixelPoints.map(p => p.py));
                commentPositions.push({ text: standard.comment, x: (minPx + maxPx) / 2, y: (minPy + maxPy) / 2, height: fontSize });
            });
            commentPositions.sort((a, b) => a.y - b.y);
            const margin = 4;
            for (let i = 1; i < commentPositions.length; i++) {
                const prev = commentPositions[i-1];
                const current = commentPositions[i];
                if (current.y - current.height / 2 < prev.y + prev.height / 2 + margin) {
                    current.y = prev.y + prev.height / 2 + margin + current.height / 2;
                }
            }
            commentPositions.forEach(pos => {
                ctx.fillStyle = '#000000';
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(pos.text, pos.x, pos.y);
            });
        }
        ctx.restore();
    }
};

Chart.register(ChartDataLabels);
const customCanvasBackgroundColor = {
    id: 'customCanvasBackgroundColor',
    beforeDraw: (chart) => {
        const bgColor = chart.options.plugins.backgroundColor;
        if (bgColor) {
            const { ctx } = chart;
            ctx.save();
            ctx.globalCompositeOperation = 'destination-over';
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, chart.width, chart.height);
            ctx.restore();
        }
    }
};
Chart.register(customCanvasBackgroundColor);

// åˆæœŸåŒ–ãƒ•ãƒ­ãƒ¼
window.onload = function() {
    imageExtractor.init();
    loadStandardsFromLocalStorage();
    populateStandardGroupSelector();
    renderReferenceStandardsTable();
    renderTable();
    renderAllCharts();
    setupHelpModal();
    setupLayerOrderModalDragAndDrop();
    
    // ãƒ•ãƒƒã‚¿ãƒ¼æ›´æ–°
    const lastUpdatedEl = document.getElementById('lastUpdated');
    if (lastUpdatedEl) { 
        const today = new Date();
        const y = today.getFullYear();
        const m = today.getMonth() + 1;
        const d = today.getDate();
        lastUpdatedEl.textContent = `æœ€çµ‚æ›´æ–°æ—¥: ${y}å¹´${m}æœˆ${d}æ—¥`; 
    }

    const legalToggle = document.getElementById('legal-toggle');
    const legalDetails = document.getElementById('legal-details');
    if (legalToggle && legalDetails) {
        legalToggle.addEventListener('click', function() {
            const isHidden = legalDetails.style.display === 'none';
            legalDetails.style.display = isHidden ? 'block' : 'none';
            legalToggle.textContent = isHidden ? 'å…è²¬äº‹é … (ã‚¯ãƒªãƒƒã‚¯ã§éè¡¨ç¤º)' : 'å…è²¬äº‹é … (ã‚¯ãƒªãƒƒã‚¯ã§è¡¨ç¤º)';
            if (isHidden) { setTimeout(() => { legalDetails.scrollIntoView({ behavior: 'smooth', block: 'end' }); }, 100); }
        });
    }
};

function setupHelpModal() {
    const helpModal = document.getElementById('helpModal');
    const helpButton = document.getElementById('helpButton');
    const closeBtn = helpModal.querySelector('.close-btn');
    helpButton.onclick = () => { helpModal.style.display = 'flex'; };
    closeBtn.onclick = () => { helpModal.style.display = 'none'; };
    helpModal.onclick = (event) => { if (event.target === helpModal) { helpModal.style.display = 'none'; } };
}

function openTab(evt, tabName) {
    document.querySelectorAll('.tab-content').forEach(tc => tc.style.display = 'none');
    document.querySelectorAll('.tab-link').forEach(tl => tl.classList.remove('active'));
    document.getElementById(tabName).style.display = 'block';
    evt.currentTarget.classList.add('active');
    setTimeout(() => {
        if (tabName === 'GradationCurve') { Object.values(chartInstances).forEach(chart => chart?.resize()); }
        if (tabName === 'Composition') { if (compositionChart) compositionChart.resize(); Object.values(compositionChartInstances).forEach(chart => chart?.resize()); }
    }, 10);
}

function populateStandardGroupSelector() {
    const selector = document.getElementById('standardGroupSelector');
    selector.innerHTML = '';
    ['all', 'none', ...standardGroups.map(g => g.groupName)].forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = {all: 'ã™ã¹ã¦è¡¨ç¤º', none: 'è¡¨ç¤ºã—ãªã„'}[name] || name;
        selector.appendChild(option);
    });
    selector.value = 'none';
}

function renderReferenceStandardsTable(openIndex = -1) {
    const container = document.getElementById('standardsContainer');
    container.innerHTML = standardGroups.map((group, groupIndex) => `
        <div class="accordion-group">
            <div class="accordion-header" onclick="toggleAccordion(this)">
                <span class="toggle-icon">${openIndex === groupIndex ? 'â–¼' : 'â–¶'}</span>
                <input type="text" class="group-name-input" value="${group.groupName}" oninput="updateGroupName(${groupIndex}, this.value)" placeholder="ã‚°ãƒ«ãƒ¼ãƒ—åã‚’å…¥åŠ›" onclick="event.stopPropagation()">
                <div class="header-actions"><button class="btn-del" onclick="event.stopPropagation(); deleteGroup(${groupIndex})">ã‚°ãƒ«ãƒ¼ãƒ—å‰Šé™¤</button></div>
            </div>
            <div class="accordion-content ${openIndex === groupIndex ? 'open' : ''}">
                <div class="table-container">
                    ${group.standards.length > 0 ? `
                    <table>
                        <thead><tr><th>è¡¨ç¤º</th><th>åŸºæº–åç§°</th><th>ã‚³ãƒ¡ãƒ³ãƒˆ</th><th>å¡—ã‚Šã¤ã¶ã—</th><th>è‰²</th><th>é€æ˜åº¦</th><th>ãƒ‡ãƒ¼ã‚¿</th><th>ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</th></tr></thead>
                        <tbody>
                        ${group.standards.map((standard, standardIndex) => `
                            <tr>
                                <td class="cell-center"><input type="checkbox" ${standard.visible ? 'checked' : ''} onchange="updateStandard(${groupIndex}, ${standardIndex}, 'visible', this.checked)"></td>
                                <td><input type="text" value="${standard.name}" oninput="updateStandard(${groupIndex}, ${standardIndex}, 'name', this.value)"></td>
                                <td><input type="text" value="${standard.comment || ''}" oninput="updateStandard(${groupIndex}, ${standardIndex}, 'comment', this.value, this)"></td>
                                <td class="cell-center"><input type="checkbox" ${standard.fill ? 'checked' : ''} onchange="updateStandard(${groupIndex}, ${standardIndex}, 'fill', this.checked)"></td>
                                <td><input type="color" value="${standard.color}" oninput="updateStandard(${groupIndex}, ${standardIndex}, 'color', this.value)"></td>
                                <td><input type="number" min="0" max="1" step="0.05" value="${standard.opacity}" oninput="updateStandard(${groupIndex}, ${standardIndex}, 'opacity', this.valueAsNumber)"></td>
                                <td><textarea class="data-editor" oninput="updateStandard(${groupIndex}, ${standardIndex}, 'dataStr', this.value)">${standard.dataStr}</textarea></td>
                                <td style="padding: 4px; display: flex; flex-direction: column; gap: 4px; min-width: 110px;">
                                    <button class="btn-import btn-sm" style="background-color: #8b5cf6; width: 100%;" onclick="imageExtractor.open(${groupIndex}, ${standardIndex})">ç”»åƒã‹ã‚‰èª­å–</button>
                                    <button class="btn-del btn-sm" style="width: 100%;" onclick="deleteStandard(${groupIndex}, ${standardIndex})">å‰Šé™¤</button>
                                </td>
                            </tr>`).join('')}
                        </tbody>
                    </table>` : `<p class="help-text" style="text-align:center;">åŸºæº–ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>`}
                </div>
                <button class="btn-add" onclick="addNewStandardToGroup(${groupIndex})">ï¼‹ ã“ã®ã‚°ãƒ«ãƒ¼ãƒ—ã«åŸºæº–ã‚’è¿½åŠ </button>
            </div>
        </div>
    `).join('');
}
function toggleAccordion(headerEl) {
    const content = headerEl.nextElementSibling;
    const icon = headerEl.querySelector('.toggle-icon');
    const isOpen = content.classList.toggle('open');
    icon.textContent = isOpen ? 'â–¼' : 'â–¶';
}
function addNewGroup() { standardGroups.push({ groupName: `æ–°è¦ã‚°ãƒ«ãƒ¼ãƒ— ${standardGroups.length + 1}`, standards: [] }); updateAndRenderStandards(standardGroups.length - 1); }
function deleteGroup(index) { if (confirm(`ã‚°ãƒ«ãƒ¼ãƒ—ã€Œ${standardGroups[index].groupName}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) { standardGroups.splice(index, 1); updateAndRenderStandards(); } }
function addNewStandardToGroup(groupIndex) {
    standardGroups[groupIndex].standards.push({
        id: Date.now() + Math.random(), name: `æ–°è¦åŸºæº–`, comment: '', visible: true, fill: true, color: '#808080', opacity: 0.25,
        dataStr: '# ä¸Šé™\n0.1, 80\n1, 100\n---\n# ä¸‹é™\n0.1, 20\n1, 40', points: []
    });
    updateAndRenderStandards(groupIndex);
}
function deleteStandard(groupIndex, standardIndex) { if (confirm('ã“ã®åŸºæº–ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) { standardGroups[groupIndex].standards.splice(standardIndex, 1); updateAndRenderStandards(groupIndex); } }
function updateAndRenderStandards(openIndex = -1) {
    saveStandardsToLocalStorage();
    populateStandardGroupSelector();
    renderReferenceStandardsTable(openIndex);
    renderAllCharts();
}
let standardDebounceTimer;
function updateStandard(gIdx, sIdx, field, value) {
    standardGroups[gIdx].standards[sIdx][field] = value;
    clearTimeout(standardDebounceTimer);
    standardDebounceTimer = setTimeout(() => { updateAndRenderStandards(gIdx); }, 300);
}
function updateGroupName(index, name) {
    standardGroups[index].groupName = name;
    clearTimeout(standardDebounceTimer);
    standardDebounceTimer = setTimeout(() => { updateAndRenderStandards(index); }, 300);
}

function parseStandardPolygon(dataStr, isFill) {
    const parse = (str) => (str || '').trim().split(/[\r\n]+/).map(line => {
        if (line.trim().startsWith('#') || line.trim() === '') return null;
        const [size, percent] = line.split(/[,\t\s]+/).map(parseFloat);
        return !isNaN(size) && !isNaN(percent) ? { x: size, y: percent } : null;
    }).filter(Boolean);
    if (isFill) {
        const [upperStr, lowerStr] = (dataStr || '').trim().split(/\n---\n/);
        const upper = parse(upperStr).sort((a, b) => a.x - b.x);
        const lower = parse(lowerStr).sort((a, b) => b.x - a.x);
        return [...upper, ...lower];
    }
    return parse(dataStr);
}
function saveStandardsToLocalStorage() { localStorage.setItem('referenceStandards', JSON.stringify(standardGroups)); }
function loadStandardsFromLocalStorage() {
    try {
        const stored = localStorage.getItem('referenceStandards');
        if (stored && stored !== "undefined") {
            standardGroups = JSON.parse(stored);
        } else {
            // åˆæœŸãƒ‡ãƒ¼ã‚¿
            standardGroups = [{
                groupName: "æ¶²çŠ¶åŒ–é–¢é€£", standards: [{
                    id: 1, name: 'æ¶²çŠ¶åŒ–ã®å¯èƒ½æ€§ã®ã‚ã‚‹ç¯„å›²', comment: 'æ³¨æ„', visible: true, fill: true, color: '#6b7280', opacity: 0.25,
                    dataStr: '0.06, 40\n0.1, 68\n0.2, 90\n0.6, 100\n10, 100\n---\n0.075, 0\n0.15, 5\n0.4, 20\n1.0, 45\n2.0, 65\n10, 95'
                }]
            }];
        }
    } catch(e) { console.error("Load Error", e); standardGroups = []; }
    standardGroups.forEach(g => g.standards.forEach(s => { s.opacity = s.opacity ?? 0.25; s.comment = s.comment ?? ''; }));
}
function exportStandards() {
    const blob = new Blob([JSON.stringify(standardGroups, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'grain_size_standards.json';
    a.click();
    URL.revokeObjectURL(a.href);
}
function handleFileRead(file, callback) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => callback(e.target.result);
    reader.readAsText(file);
}
function handleStandardsImport(event) {
    handleFileRead(event.target.files[0], (text) => {
        try {
            const imported = JSON.parse(text);
            if (!Array.isArray(imported)) throw new Error('Invalid format');
            standardGroups = imported;
            updateAndRenderStandards();
            alert('åŸºæº–è¨­å®šã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚');
        } catch (e) { alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚'); }
    });
    event.target.value = '';
}
function renderTable() {
    document.getElementById('tableBody').innerHTML = samples.map((sample, index) => `
        <tr>
            <td class="cell-center"><input type="checkbox" class="row-checkbox" data-index="${index}"></td>
            <td style="text-align:center; background:#f9fafb;">${index + 1}</td>
            <td><input type="text" value="${sample.location || ''}" oninput="updateSample(${index}, 'location', this.value)"></td>
            <td><input type="text" value="${sample.name}" oninput="updateSample(${index}, 'name', this.value)"></td>
            <td><input type="number" value="${sample.depth || ''}" oninput="updateSample(${index}, 'depth', this.value)"></td>
            <td><input type="text" value="${sample.soilType}" oninput="updateSample(${index}, 'soilType', this.value)"></td>
            <td><input type="text" value="${sample.layer}" oninput="updateSample(${index}, 'layer', this.value)"></td>
            <td><textarea class="data-editor" oninput="updateSample(${index}, 'dataStr', this.value)">${sample.dataStr || ''}</textarea></td>
        </tr>
    `).join('');
    document.getElementById('selectAllCheckbox').onchange = (e) =>
        document.querySelectorAll('.row-checkbox').forEach(cb => cb.checked = e.target.checked);
    renderLocationFilter();
}
let debounceTimer;
function updateSample(index, field, value) {
    samples[index][field] = value;
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
        renderAllCharts();
        if (field === 'location') renderLocationFilter();
    }, 300);
}

function addNewRow() {
    const newId = samples.length > 0 ? Math.max(...samples.map(s => s.id)) + 1 : 1;
    samples.push({ id: newId, location: '', name: `è©¦æ–™${newId}`, depth: '', soilType: '', layer: '1', dataStr: '' });
    renderTable();
    renderAllCharts();
}

function deleteSelectedSamples() {
    const indices = [...document.querySelectorAll('.row-checkbox:checked')].map(cb => parseInt(cb.dataset.index, 10));
    if (indices.length === 0) return alert('å‰Šé™¤ã™ã‚‹è©¦æ–™ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚');
    if (confirm(`${indices.length}ä»¶ã®è©¦æ–™ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ`)) {
        samples = samples.filter((_, i) => !indices.includes(i));
        renderTable();
        renderAllCharts();
    }
}

function renderLocationFilter() {
    const container = document.getElementById('locationFilterContainer');
    const locations = [...new Set(samples.map(s => s.location || 'ï¼ˆåœ°ç‚¹åãªã—ï¼‰'))].sort();
    if (locations.length <= 1) {
        container.style.display = 'none';
        return;
    }
    container.style.display = 'flex';
    container.innerHTML = `<div style="font-weight: 500;">åœ°ç‚¹ã§çµã‚Šè¾¼ã¿:</div><div style="display: flex; flex-wrap: wrap; gap: 10px;">` +
        locations.map(loc => `<label style="display:flex; align-items:center; gap:5px; cursor:pointer;"><input type="checkbox" class="location-filter-cb" value="${loc}" checked onchange="renderAllCharts()"> ${loc}</label>`).join('') +
        `</div>`;
}

function getFilteredSamples() {
    const cbs = document.querySelectorAll('.location-filter-cb');
    if (cbs.length === 0) return [...samples];
    const selected = [...cbs].filter(cb => cb.checked).map(cb => cb.value);
    return samples.filter(s => selected.includes(s.location || 'ï¼ˆåœ°ç‚¹åãªã—ï¼‰'));
}

function parseDataString(str) {
    return (str || '').trim().split(/[\r\n]+/).map(line => {
        const [size, percent] = line.split(/[,\t\s]+/).map(parseFloat);
        return !isNaN(size) && !isNaN(percent) ? { x: size, y: percent } : null;
    }).filter(Boolean).sort((a, b) => b.x - a.x);
}

// --- Ucè¨ˆç®—ç”¨é–¢æ•° ---
function getDiameterAtPercent(targetPercent, points) {
    if (!points || points.length < 2) return null;
    const maxP = Math.max(...points.map(p => p.y));
    const minP = Math.min(...points.map(p => p.y));
    if (targetPercent > maxP || targetPercent < minP) return null;

    for (let i = 0; i < points.length - 1; i++) {
        const p1 = points[i];
        const p2 = points[i+1];
        const yMax = Math.max(p1.y, p2.y);
        const yMin = Math.min(p1.y, p2.y);
        if (targetPercent <= yMax && targetPercent >= yMin) {
            if (p2.y - p1.y === 0) return p1.x;
            const logX1 = Math.log(p1.x);
            const logX2 = Math.log(p2.x);
            const ratio = (targetPercent - p1.y) / (p2.y - p1.y);
            return Math.exp(logX1 + ratio * (logX2 - logX1));
        }
    }
    return null;
}

// Ucã‚«ãƒ†ã‚´ãƒªãƒ¼ã‚’è¿”ã™é–¢æ•°
function getUcCategory(dataStr) {
    const points = parseDataString(dataStr);
    const d10 = getDiameterAtPercent(10, points);
    const d60 = getDiameterAtPercent(60, points);
    if (d10 !== null && d60 !== null && d10 !== 0) {
        const uc = d60 / d10;
        return uc >= 3.5 ? 'Ucâ‰§3.5' : 'Uc<3.5';
    }
    return 'Ucåˆ¤å®šä¸èƒ½';
}

// Ucæ•°å€¤ã‚’è¿”ã™é–¢æ•° (è¡¨ç¤ºç”¨)
function getUcValueText(dataStr) {
    const points = parseDataString(dataStr);
    const d10 = getDiameterAtPercent(10, points);
    const d60 = getDiameterAtPercent(60, points);
    if (d10 !== null && d60 !== null && d10 !== 0) {
        const uc = d60 / d10;
        return `(Uc=${uc.toFixed(1)})`;
    }
    return '';
}

function generateStandardSelectHTML(currentValue) {
    const options = ['all', 'none', ...standardGroups.map(g => g.groupName)].map(name => {
        const label = {all: 'ã™ã¹ã¦è¡¨ç¤º', none: 'è¡¨ç¤ºã—ãªã„'}[name] || name;
        const selected = (name === currentValue) ? 'selected' : '';
        return `<option value="${name}" ${selected}>${label}</option>`;
    }).join('');
    return `<select class="dark-input" style="width:auto; padding:2px; font-size:11px; margin-right:5px;" onchange="updateChartByLocalSelect(this, event)">${options}</select>`;
}

function updateChartByLocalSelect(selectElement, event) {
    const selectedStandard = selectElement.value;
    const chartBox = selectElement.closest('.chart-box');
    const groupKey = chartBox.dataset.groupKey;
    const chart = chartInstances[groupKey];
    if (!chart) return;
    const newOptions = getChartOptions(selectedStandard);
    chart.options.plugins.titleSuffix = newOptions.plugins.titleSuffix;
    chart.options.plugins.referenceCurvePlugin.standards = newOptions.plugins.referenceCurvePlugin.standards;
    chart.update();
}

function renderAllCharts() {
    renderGradationCharts();
    renderCompositionChart();
}

// updateAllChartOptions: å‡¡ä¾‹è¨­å®šå¤‰æ›´æ™‚ãªã©ã¯ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå†æ§‹ç¯‰ãŒå¿…è¦ãªã®ã§å†æç”»ã™ã‚‹
function updateAllChartOptions() {
    renderGradationCharts(); 
    // â€»å˜ç´”ãªoptionæ›´æ–°ã ã‘ãªã‚‰update()ã§è‰¯ã„ãŒã€
    // HTMLå‡¡ä¾‹ã‚„ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´ã‚’å«ã‚€ãŸã‚å…¨ä½“å†æç”»ã®æ–¹ãŒå®‰å…¨ã§ç¢ºå®Ÿã§ã™ã€‚
}

function getChartOptions(selectedStandardName = null) {
    const textColor = '#000000';
    const globalSelect = document.getElementById('standardGroupSelector');
    const selectedGroup = selectedStandardName || (globalSelect ? globalSelect.value : 'none');
    
    let standardsToRender = [];
    let titleSuffix = '';
    if (selectedGroup === 'all') {
        standardsToRender = standardGroups.flatMap(g => g.standards);
    } else if (selectedGroup !== 'none') {
        const group = standardGroups.find(g => g.groupName === selectedGroup);
        if (group) {
            standardsToRender = group.standards;
            titleSuffix = ` (åŸºæº–: ${selectedGroup})`;
        }
    }
    standardsToRender.forEach(s => s.points = parseStandardPolygon(s.dataStr, s.fill));

    return {
        animation: { duration: 0 }, responsive: true, maintainAspectRatio: false,
        layout: { padding: { top: 40 } },
        scales: {
            x: { type: 'logarithmic', min: 0.001, max: 100, title: { display: true, text: 'ç²’å¾„ (mm)', color: textColor }, grid: { display: document.getElementById('gridToggle').checked, color: document.getElementById('soilBgToggle').checked ? '#d1d5db' : '#d1d5db' }, ticks: { color: textColor, callback: v => [0.001, 0.01, 0.1, 1, 10, 100].includes(v) ? v : '', autoSkip: false, maxRotation: 0 } },
            y: { min: 0, max: 100, title: { display: true, text: 'é€šéè³ªé‡ç™¾åˆ†ç‡ (%)', color: textColor }, grid: { display: document.getElementById('gridToggle').checked, color: document.getElementById('soilBgToggle').checked ? '#d1d5db' : '#d1d5db' }, ticks: { color: textColor } }
        },
        plugins: {
            // â˜…å¤‰æ›´: Chart.jsæ¨™æº–ã®å‡¡ä¾‹ã‚’ç„¡åŠ¹åŒ– (è‡ªä½œHTMLå‡¡ä¾‹ã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚)
            title: { display: false, align: 'start', font: { size: 16, weight: 'bold' }, padding: { bottom: 10 }, color: textColor, text: '' },
            legend: {
                display: false, // HTMLå‡¡ä¾‹ã‚’ä½¿ã†ãŸã‚false
                labels: {
                    // ãƒ©ãƒ™ãƒ«ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ã¯HTMLå‡¡ä¾‹ç”Ÿæˆæ™‚ã«å†åˆ©ç”¨ã™ã‚‹ãŸã‚ã«æ®‹ã™
                    usePointStyle: true, color: textColor,
                    generateLabels: function(chart) {
                        const originalLabels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                        const markerVisible = document.getElementById('markerToggle').checked;
                        if (!markerVisible) { originalLabels.forEach(label => { label.pointStyle = 'rect'; }); }
                        return originalLabels;
                    }
                }
            },
            soilClassificationLegend: { legendHeight: 30, showBackground: document.getElementById('soilBgToggle').checked },
            referenceCurvePlugin: { standards: standardsToRender },
            datalabels: { display: document.getElementById('dataLabelsToggle').checked, align: 'top', backgroundColor: 'rgba(255,255,255,0.7)', borderRadius: 4, color: textColor, font: { size: 10 }, formatter: p => p.y.toFixed(1) },
            titleSuffix: titleSuffix
        }
    };
}

// --- ã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´ç”¨é–¢æ•° (ç²’å¾„åŠ ç©æ›²ç·š) ---
function updateChartLayout() {
    const cols = document.getElementById('chartColumnsInput').value;
    const container = document.getElementById('chartsContainer');
    container.className = 'charts-wrapper';
    if(cols === '2') container.classList.add('cols-2');
    if(cols === '3') container.classList.add('cols-3');
    Object.values(chartInstances).forEach(chart => chart.resize());
}

function renderGradationCharts() {
    const container = document.getElementById('chartsContainer');
    const filteredSamples = getFilteredSamples();
    const groupingCriteria = document.getElementById('groupingCriteria').value;
    const globalStandardValue = document.getElementById('standardGroupSelector').value;
    const splitByUc = document.getElementById('splitByUcToggle').checked;
    
    // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­å®šã®å–å¾—
    const isLegendRight = document.getElementById('legendStyleToggle').checked;
    const chartHeightVal = document.getElementById('chartHeightInput').value;

    const getGroupKey = (sample) => {
        let baseKey = '';
        switch (groupingCriteria) {
            case 'location': baseKey = sample.location || 'ï¼ˆåœ°ç‚¹åãªã—ï¼‰'; break;
            case 'soilType': baseKey = sample.soilType || 'ï¼ˆåœŸè³ªåãªã—ï¼‰'; break;
            case 'all':      baseKey = 'ã™ã¹ã¦ã®è©¦æ–™'; break;
            case 'each':     baseKey = String(sample.id); break;
            default:         baseKey = sample.layer || 'ï¼ˆåœŸå±¤ãªã—ï¼‰'; break;
        }
        if (splitByUc && groupingCriteria !== 'each') {
             const ucCategory = getUcCategory(sample.dataStr);
             return `${baseKey} [${ucCategory}]`;
        }
        return baseKey;
    };

    const getGroupTitle = (groupKey, groupSamples) => {
        const firstSample = groupSamples[0];
        if (groupKey.includes('[')) { return `ã‚°ãƒ«ãƒ¼ãƒ—: ${groupKey}`; }
        switch (groupingCriteria) {
            case 'location': return `åœ°ç‚¹å: ${groupKey}`;
            case 'soilType':
                const locations = [...new Set(groupSamples.map(s => s.location).filter(Boolean))].join(', ');
                return `åœŸè³ªå: ${groupKey}` + (locations ? ` / åœ°ç‚¹: ${locations}` : '');
            case 'all':      return 'ã™ã¹ã¦ã®è©¦æ–™';
            case 'each': return `è©¦æ–™: ${firstSample.location || ''} ${firstSample.name} (GL-${firstSample.depth || '?'}m)`;
            default:
                const soilTypes = [...new Set(groupSamples.map(s => s.soilType).filter(Boolean))].join(', ');
                return `åœŸå±¤: ${groupKey}` + (soilTypes ? ` / åœŸè³ªå: ${soilTypes}` : '');
        }
    };
    
    const groupedSamples = filteredSamples.reduce((acc, sample) => {
        const key = getGroupKey(sample);
        if (!acc[key]) acc[key] = [];
        acc[key].push(sample);
        return acc;
    }, {});
    
    // ã‚«ã‚¹ã‚¿ãƒ ã‚½ãƒ¼ãƒˆ
    let keys = Object.keys(groupedSamples);
    const groupKeys = getCustomSortedKeys(keys, groupingCriteria);

    // ä¸è¦ãªã‚°ãƒ©ãƒ•ã®ç ´æ£„
    Object.keys(chartInstances).filter(key => !groupKeys.includes(String(key))).forEach(key => {
        chartInstances[key]?.destroy();
        delete chartInstances[key];
        document.querySelector(`.chart-box[data-group-key='${key}']`)?.remove();
    });
    
    const fragment = document.createDocumentFragment();
    groupKeys.forEach(groupKey => {
        let box = container.querySelector(`.chart-box[data-group-key='${groupKey}']`);
        const groupSamples = groupedSamples[groupKey];
        const titleText = getGroupTitle(groupKey, groupSamples);

        // æ–°è¦ä½œæˆæ™‚ã¾ãŸã¯æ§‹é€ å¤‰æ›´ãŒå¿…è¦ãªå ´åˆ
        if (!box) {
             box = document.createElement('div');
             box.className = 'chart-box';
             box.dataset.groupKey = groupKey;
             
             // â˜…å¤‰æ›´ç‚¹: chart-body ãƒ©ãƒƒãƒ‘ãƒ¼ã¨è‡ªä½œå‡¡ä¾‹ã‚¨ãƒªã‚¢ã‚’è¿½åŠ 
             // isLegendRight ã«å¿œã˜ã¦ layout-right ã‚¯ãƒ©ã‚¹ã‚’ä»˜ä¸
             box.innerHTML = `
                <div class="chart-header-bar">
                    <h3 class="chart-title-html" title="${titleText}">${titleText}</h3>
                    <div class="chart-actions-static">
                        <span style="font-size:11px; margin-right:4px; color:#555;">åŸºæº–:</span>
                        ${generateStandardSelectHTML(globalStandardValue)}
                        <button class="btn-download" onclick="downloadChartAsImage('gradation', '${groupKey}')">ğŸ“· ä¿å­˜</button>
                    </div>
                </div>
                <div class="chart-body ${isLegendRight ? 'layout-right' : ''}">
                    <div class="chart-canvas-wrapper" style="height: ${chartHeightVal}px;">
                        <canvas></canvas>
                    </div>
                    <div class="custom-legend-container" id="legend-${groupKey.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}"></div>
                </div>`;
        } else {



             // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ä¿®æ­£ãƒ»è¿½è¨˜ â˜…â˜…â˜…
             
             // æ—¢å­˜Boxã®æ›´æ–°
             const titleEl = box.querySelector('.chart-title-html');
             if(titleEl) { titleEl.textContent = titleText; titleEl.title = titleText; }
             
             const select = box.querySelector('select');
             if (select) {
                 const temp = document.createElement('div');
                 temp.innerHTML = generateStandardSelectHTML(globalStandardValue);
                 select.innerHTML = temp.firstChild.innerHTML;
                 select.value = globalStandardValue;
             }

             // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚¯ãƒ©ã‚¹ã¨é«˜ã•ã®æ›´æ–°
             const bodyDiv = box.querySelector('.chart-body');
             if(bodyDiv) {
                 if(isLegendRight) {
                     bodyDiv.classList.add('layout-right');
                 } else {
                     bodyDiv.classList.remove('layout-right');
                 }
             }
             const wrapper = box.querySelector('.chart-canvas-wrapper');
             if(wrapper) wrapper.style.height = `${chartHeightVal}px`;

             // â˜…è¿½åŠ : ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´ã«ä¼´ã„ã€ã‚°ãƒ©ãƒ•ã®ã‚µã‚¤ã‚ºã‚’å¼·åˆ¶çš„ã«åˆã‚ã›ã‚‹
             if (chartInstances[groupKey]) {
                 chartInstances[groupKey].resize();
             }
        }
        fragment.appendChild(box);
    });





    container.innerHTML = '';
    container.appendChild(fragment);

    groupKeys.forEach(groupKey => {
        const commonOptions = getChartOptions(globalStandardValue);
        const groupSamples = groupedSamples[groupKey];
        const datasets = groupSamples.map((s, i) => {
            let labelStr = [...document.querySelectorAll('.legend-option:checked')].map(opt => ({
                location: s.location, name: s.name, depth: s.depth ? `GL-${s.depth}m` : '', soilType: s.soilType
            }[opt.value])).filter(Boolean).join(', ') || `è©¦æ–™${s.id}`;
            
            if(splitByUc) {
                labelStr += ' ' + getUcValueText(s.dataStr);
            }

            return {
                label: labelStr,
                data: parseDataString(s.dataStr),
                borderColor: colors[i % colors.length], backgroundColor: colors[i % colors.length],
                pointStyle: pointStyles[i % pointStyles.length], radius: document.getElementById('markerToggle').checked ? 4 : 0,
                borderWidth: 2, showLine: true, tension: 0.1, clip: false 
            };
        });
        const titleText = getGroupTitle(groupKey, groupSamples);
        
        const box = container.querySelector(`.chart-box[data-group-key='${groupKey}']`);
        
        let chart;
        if (chartInstances[groupKey]) {
            chart = chartInstances[groupKey];
            chart.data.datasets = datasets;
            chart.options.plugins.title.text = titleText + commonOptions.plugins.titleSuffix;
            Object.assign(chart.options.plugins.legend, commonOptions.plugins.legend);
            chart.options.plugins.referenceCurvePlugin.standards = commonOptions.plugins.referenceCurvePlugin.standards;
            chart.update();
        } else {
            commonOptions.plugins.title.text = titleText + commonOptions.plugins.titleSuffix;
            chart = new Chart(box.querySelector('canvas'), { type: 'scatter', data: { datasets }, plugins: [soilClassificationPlugin, referenceCurvePlugin], options: commonOptions });
            chartInstances[groupKey] = chart;
        }

        // â˜…â˜…â˜… HTMLå‡¡ä¾‹ã®ç”Ÿæˆãƒ»æ›´æ–° (ã‚µã‚¤ã‚ºæŒ‡å®šè¾¼ã¿) â˜…â˜…â˜…
        const legendContainer = box.querySelector('.custom-legend-container');
        generateCustomLegend(chart, legendContainer);
    });
    
    // ã‚«ãƒ©ãƒ è¨­å®šå†é©ç”¨
    const cols = document.getElementById('chartColumnsInput').value;
    container.className = 'charts-wrapper';
    if(cols === '2') container.classList.add('cols-2');
    if(cols === '3') container.classList.add('cols-3');

    if (groupKeys.length === 0) container.innerHTML = '<p class="help-text" style="text-align:center;">è¡¨ç¤ºã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>';
}

// --- è‡ªä½œHTMLå‡¡ä¾‹ã®ç”Ÿæˆ ---
function generateCustomLegend(chart, container) {
    if (!container) return;
    container.innerHTML = '';
    
    // ã‚µã‚¤ãƒ‰ãƒãƒ¼ã®è¨­å®šå€¤ã‚’å–å¾—
    const fontSizeVal = document.getElementById('legendFontSize').value; // px
    const markerSizeVal = document.getElementById('legendMarkerSize').value; // px
    const fontSize = fontSizeVal ? `${fontSizeVal}px` : '12px';
    const markerSize = markerSizeVal ? `${markerSizeVal}px` : '12px';

    const items = chart.options.plugins.legend.labels.generateLabels(chart);

    items.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = `legend-item ${item.hidden ? 'hidden-item' : ''}`;
        
        // å‡¡ä¾‹é …ç›®ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºé©ç”¨
        itemDiv.style.fontSize = fontSize;
        
        const marker = document.createElement('span');
        marker.className = 'legend-marker';
        marker.style.backgroundColor = item.fillStyle;
        marker.style.borderColor = item.strokeStyle;
        marker.style.borderWidth = item.lineWidth + 'px';
        
        // ãƒãƒ¼ã‚«ãƒ¼ã‚µã‚¤ã‚ºé©ç”¨
        marker.style.width = markerSize;
        marker.style.height = markerSize;
        
        if (item.pointStyle === 'circle') {
            marker.style.borderRadius = '50%';
        } else {
            marker.style.borderRadius = '0';
        }

        const text = document.createElement('span');
        text.textContent = item.text;
        
        itemDiv.appendChild(marker);
        itemDiv.appendChild(text);

        itemDiv.onclick = () => {
            const index = item.datasetIndex;
            const isVisible = chart.isDatasetVisible(index);
            if (isVisible) {
                chart.hide(index);
                itemDiv.classList.add('hidden-item');
            } else {
                chart.show(index);
                itemDiv.classList.remove('hidden-item');
            }
        };

        container.appendChild(itemDiv);
    });
}

function getPassingPercent(targetX, points, method = 'logarithmic') {
    if (!points || points.length === 0) return 0;
    if (targetX >= points[0].x) return points[0].y;
    if (targetX <= points[points.length - 1].x) return points[points.length - 1].y;
    for (let i = 0; i < points.length - 1; i++) {
        if (points[i].x >= targetX && points[i + 1].x < targetX) {
            const [p1, p2] = [points[i], points[i + 1]];
            let interpolatedY;
            if (method === 'linear') { interpolatedY = p1.y + (p2.y - p1.y) * (targetX - p1.x) / (p2.x - p1.x); } 
            else { interpolatedY = p1.y + (p2.y - p1.y) * (Math.log(targetX) - Math.log(p1.x)) / (Math.log(p2.x) - Math.log(p1.x)); }
            return Math.max(0, Math.min(100, interpolatedY));
        }
    }
    return 0;
}

function calculateComposition(dataStr) {
    const points = parseDataString(dataStr);
    if (points.length < 2) return { gravel: 0, sand: 0, silt: 0, clay: 0, fc: 0 };
    const interpolationMethod = document.getElementById('interpolationMethod')?.value || 'logarithmic';
    const p2 = getPassingPercent(2, points, interpolationMethod);
    const p0_075 = getPassingPercent(0.075, points, interpolationMethod);
    const p0_005 = getPassingPercent(0.005, points, interpolationMethod);
    const gravel = 100 - p2; const sand = p2 - p0_075; const silt = p0_075 - p0_005; const clay = p0_005;
    return { gravel, sand, silt, clay, fc: silt + clay };
}

// --- ã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå¤‰æ›´ç”¨é–¢æ•° (ç²’åº¦æ§‹æˆ) ---
function updateCompositionLayout() {
    const cols = document.getElementById('compositionColumns').value;
    const container = document.getElementById('compositionContainer');
    container.className = 'composition-wrapper';
    if(cols === '2') container.classList.add('cols-2');
    if (compositionChart) compositionChart.resize();
    Object.values(compositionChartInstances).forEach(chart => chart.resize());
}

function renderCompositionChart() {
    const container = document.getElementById('compositionContainer');
    container.innerHTML = '';
    const cols = document.getElementById('compositionColumns').value;
    container.className = 'composition-wrapper';
    if(cols === '2') container.classList.add('cols-2');

    const filteredSamples = getFilteredSamples();
    if (filteredSamples.length === 0) { container.innerHTML = '<p class="help-text" style="text-align:center;">è¡¨ç¤ºãƒ‡ãƒ¼ã‚¿ãªã—</p>'; return; }
    Object.values(compositionChartInstances).forEach(chart => chart.destroy());
    compositionChartInstances = {};
    if (compositionChart) { compositionChart.destroy(); compositionChart = null; }
    const displayMode = document.getElementById('compositionDisplayMode').value;
    const sortOrder = document.getElementById('sortOrder').value;
    const textColor = '#000000';
    const interpolationMethodSelect = document.getElementById('interpolationMethod');
    const interpolationMethodText = interpolationMethodSelect.options[interpolationMethodSelect.selectedIndex].text;

    if (displayMode === 'grouped') {
        const groupedSamples = filteredSamples.reduce((acc, sample) => { const key = sample.layer || 'ï¼ˆåœŸå±¤ãªã—ï¼‰'; if (!acc[key]) acc[key] = []; acc[key].push(sample); return acc; }, {});
        
        let keys = Object.keys(groupedSamples);
        const groupKeys = getCustomSortedKeys(keys, 'layer');
        
        groupKeys.forEach(groupKey => {
            const samplesInGroup = groupedSamples[groupKey];
            const box = document.createElement('div');
            box.className = 'chart-box';
            
            const titleText = `ç²’åº¦æ§‹æˆ (åœŸå±¤: ${groupKey}, ${interpolationMethodText})`;
            
            box.innerHTML = `
                <div class="chart-header-bar">
                    <h3 class="chart-title-html" title="${titleText}">${titleText}</h3>
                    <div class="chart-actions-static">
                        <button class="btn-download" onclick="downloadChartAsImage('composition', '${groupKey}')">ğŸ“· ä¿å­˜</button>
                    </div>
                </div>
                <div class="chart-canvas-wrapper" style="height: ${40 * samplesInGroup.length + 100}px;">
                    <canvas></canvas>
                </div>`;
            container.appendChild(box);
            
            const sortedSamples = [...samplesInGroup].sort((a, b) => {
                if (sortOrder === 'depth') return (parseFloat(a.depth) || Infinity) - (parseFloat(b.depth) || Infinity);
                if (sortOrder === 'location') { return String(a.location).localeCompare(String(b.location)) || samples.indexOf(a) - samples.indexOf(b); }
                if (sortOrder === 'layer') {
                    const idxA = customSortOrders.layer.indexOf(a.layer) !== -1 ? customSortOrders.layer.indexOf(a.layer) : 9999;
                    const idxB = customSortOrders.layer.indexOf(b.layer) !== -1 ? customSortOrders.layer.indexOf(b.layer) : 9999;
                    return idxA - idxB || String(a.layer).localeCompare(String(b.layer));
                }
                return samples.indexOf(a) - samples.indexOf(b);
            });
            const compositions = sortedSamples.map(s => calculateComposition(s.dataStr));
            const canvas = box.querySelector('canvas');
            compositionChartInstances[groupKey] = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: sortedSamples.map(s => `${s.location || ''} ${s.name} (GL-${s.depth || '?'}m, ${s.soilType})`),
                    datasets: [
                        { type: 'line', label: 'Fc%(ç´°ç²’åˆ†å«æœ‰ç‡)', data: compositions.map(c => c.fc), showLine: false, borderColor: 'transparent', pointBackgroundColor: '#1e40af', pointRadius: 5, order: 0, datalabels: { display: true, color: '#1e40af', anchor: 'end', align: 'start', offset: 4, font: { weight: 'bold' }, formatter: v => `Fc:${v.toFixed(1)}%` } },
                        { label: 'ç²˜åœŸåˆ†(<5Î¼m)', data: compositions.map(c => c.clay), backgroundColor: '#3b82f6', stack: 'composition', order: 1 },
                        { label: 'ã‚·ãƒ«ãƒˆåˆ†(5-75Î¼m)', data: compositions.map(c => c.silt), backgroundColor: '#60a5fa', stack: 'composition', order: 1 },
                        { label: 'ç ‚åˆ†(75Î¼m-2mm)', data: compositions.map(c => c.sand), backgroundColor: '#facc15', stack: 'composition', order: 1 },
                        { label: 'ç¤«åˆ†(>2mm)', data: compositions.map(c => c.gravel), backgroundColor: '#f97316', stack: 'composition', order: 1 },
                    ]
                },
                options: {
                    animation: { duration: 0 }, indexAxis: 'y', responsive: true, maintainAspectRatio: false,
                    scales: { x: { stacked: true, min: 0, max: 100, title: { display: true, text: 'æ§‹æˆç‡ (%)', color: textColor }, ticks: { color: textColor } }, y: { stacked: true, ticks: { color: textColor } } },
                    plugins: {
                        title: { display: false, text: titleText, align: 'start', font: { size: 16, weight: 'bold' }, padding: { bottom: 15 }, color: textColor },
                        legend: { position: 'bottom', labels: { usePointStyle: true, color: textColor, generateLabels: c => c.data.datasets.map((ds, i) => ({ text: ds.label, fillStyle: ds.backgroundColor || ds.pointBackgroundColor, pointStyle: ds.type === 'line' ? 'circle' : 'rect', datasetIndex: i })) } },
                        tooltip: { callbacks: { label: ctx => `${ctx.dataset.label || ''}: ${parseFloat(ctx.raw).toFixed(2)}%` } },
                        datalabels: { display: ctx => ctx.dataset.type !== 'line', color: '#000000', font: { weight: 'bold' }, formatter: val => val < 0.01 ? '' : val.toFixed(1) }
                    }
                }
            });
        });
    } else {
        const box = document.createElement('div');
        box.className = 'chart-box';
        const titleText = `ç²’åº¦æ§‹æˆ (è£œé–“: ${interpolationMethodText}, ä¸¦ã³é †: ${{ default: 'å…¥åŠ›é †', depth: 'æ·±åº¦é †', layer: 'åœŸå±¤é †', location: 'åœ°ç‚¹ã”ã¨' }[sortOrder]})`;
        
        box.innerHTML = `
            <div class="chart-header-bar">
                <h3 class="chart-title-html" title="${titleText}">${titleText}</h3>
                <div class="chart-actions-static">
                    <button class="btn-download" onclick="downloadChartAsImage('composition', 'all')">ğŸ“· ä¿å­˜</button>
                </div>
            </div>
            <div class="chart-canvas-wrapper" style="height: ${40 * filteredSamples.length + 100}px;">
                <canvas id="compositionCanvas"></canvas>
            </div>`;
        container.appendChild(box);
        
        const sortedSamples = [...filteredSamples].sort((a, b) => {
            if (sortOrder === 'depth') return (parseFloat(a.depth) || Infinity) - (parseFloat(b.depth) || Infinity);
            if (sortOrder === 'layer') { 
                const idxA = customSortOrders.layer.indexOf(a.layer) !== -1 ? customSortOrders.layer.indexOf(a.layer) : 9999;
                const idxB = customSortOrders.layer.indexOf(b.layer) !== -1 ? customSortOrders.layer.indexOf(b.layer) : 9999;
                return idxA - idxB || String(a.layer).localeCompare(String(b.layer), undefined, { numeric: true });
            }
            if (sortOrder === 'location') { return String(a.location).localeCompare(String(b.location)) || samples.indexOf(a) - samples.indexOf(b); }
            return 0;
        });
        const compositions = sortedSamples.map(s => calculateComposition(s.dataStr));
        compositionChart = new Chart(document.getElementById('compositionCanvas'), {
            type: 'bar',
            data: {
                 labels: sortedSamples.map(s => `${s.location || ''} ${s.name} (GL-${s.depth || '?'}m, ${s.soilType})`),
                datasets: [
                    { type: 'line', label: 'Fc%(ç´°ç²’åˆ†å«æœ‰ç‡)', data: compositions.map(c => c.fc), showLine: false, borderColor: 'transparent', pointBackgroundColor: '#1e40af', pointRadius: 5, order: 0, datalabels: { display: true, color: '#1e40af', anchor: 'end', align: 'start', offset: 4, font: { weight: 'bold' }, formatter: v => `Fc:${v.toFixed(1)}%` } },
                    { label: 'ç²˜åœŸåˆ†(<5Î¼m)', data: compositions.map(c => c.clay), backgroundColor: '#3b82f6', stack: 'composition', order: 1 },
                    { label: 'ã‚·ãƒ«ãƒˆåˆ†(5-75Î¼m)', data: compositions.map(c => c.silt), backgroundColor: '#60a5fa', stack: 'composition', order: 1 },
                    { label: 'ç ‚åˆ†(75Î¼m-2mm)', data: compositions.map(c => c.sand), backgroundColor: '#facc15', stack: 'composition', order: 1 },
                    { label: 'ç¤«åˆ†(>2mm)', data: compositions.map(c => c.gravel), backgroundColor: '#f97316', stack: 'composition', order: 1 },
                ]
            },
            options: {
                animation: { duration: 0 }, indexAxis: 'y', responsive: true, maintainAspectRatio: false,
                scales: { x: { stacked: true, min: 0, max: 100, title: { display: true, text: 'æ§‹æˆç‡ (%)', color: textColor }, ticks: { color: textColor } }, y: { stacked: true, ticks: { color: textColor } } },
                plugins: {
                    title: { display: false, text: titleText, align: 'start', font: { size: 16, weight: 'bold' }, padding: { bottom: 15 }, color: textColor },
                    legend: { position: 'bottom', labels: { usePointStyle: true, color: textColor, generateLabels: c => c.data.datasets.map((ds, i) => ({ text: ds.label, fillStyle: ds.backgroundColor || ds.pointBackgroundColor, pointStyle: ds.type === 'line' ? 'circle' : 'rect', datasetIndex: i })) } },
                    tooltip: { callbacks: { label: ctx => `${ctx.dataset.label || ''}: ${parseFloat(ctx.raw).toFixed(2)}%` } },
                    datalabels: { display: ctx => ctx.dataset.type !== 'line', color: '#000000', font: { weight: 'bold' }, formatter: val => val < 4 ? '' : val.toFixed(1) }
                }
            }
        });
    }
}
function exportCSV() {
    let csv = 'åœ°ç‚¹å,è©¦æ–™å,æ·±åº¦(m),åœŸè³ªå,åœŸå±¤,ç²’å¾„(mm),é€šéç‡(%)\n';
    samples.forEach(s => parseDataString(s.dataStr).forEach(p => { csv += `${s.location || ''},${s.name},${s.depth || ''},${s.soilType},${s.layer},${p.x},${p.y}\n`; }));
    const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "ç²’å¾„ãƒ‡ãƒ¼ã‚¿.csv";
    link.click();
    URL.revokeObjectURL(link.href);
}
function handleCSVImport(event) {
    handleFileRead(event.target.files[0], (text) => {
        const lines = text.trim().split(/\r\n|\n/);
        if (lines.length < 2) return alert('ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œã‚’å«ã‚€ãƒ‡ãƒ¼ã‚¿ãŒ2è¡Œä»¥ä¸Šå¿…è¦ã§ã™ã€‚');
        const headers = lines[0].split(',').map(h => h.trim());
        const h = Object.fromEntries(headers.map((h, i) => [h, i]));
        if (!['è©¦æ–™å', 'ç²’å¾„(mm)', 'é€šéç‡(%)'].every(req => req in h)) { return alert(`CSVã«ã¯ã€Œè©¦æ–™åã€ã€Œç²’å¾„(mm)ã€ã€Œé€šéç‡(%)ã€ã®åˆ—ãŒå¿…é ˆã§ã™ã€‚`); }
        const imported = {};
        lines.slice(1).forEach(line => {
            const cols = line.split(',');
            const name = cols[h['è©¦æ–™å']]?.trim();
            if (!name) return;
            const location = cols[h['åœ°ç‚¹å']]?.trim() || '';
            const layer = cols[h['åœŸå±¤']]?.trim() || '1';
            const key = `${location}_${name}_${layer}`;
            if (!imported[key]) {
                imported[key] = { location, name, layer, depth: cols[h['æ·±åº¦(m)']]?.trim() || '', soilType: cols[h['åœŸè³ªå']]?.trim() || '', points: [] };
            }
            const size = parseFloat(cols[h['ç²’å¾„(mm)']]), percent = parseFloat(cols[h['é€šéç‡(%)']]);
            if (!isNaN(size) && !isNaN(percent)) imported[key].points.push({ size, percent });
        });
        Object.values(imported).forEach(d => {
            const dataStr = d.points.map(p => `${p.size}\t${p.percent}`).join('\n');
            const existing = samples.find(s => s.location === d.location && s.name === d.name && s.layer === d.layer);
            if (existing) Object.assign(existing, { ...d, dataStr }); else samples.push({ id: Date.now() + Math.random(), ...d, dataStr });
        });
        alert(`${Object.keys(imported).length}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿/æ›´æ–°ã—ã¾ã—ãŸã€‚`);
        renderTable(); renderAllCharts();
    });
    event.target.value = '';
}
function setChartResolution(chart, resolution) {
    return new Promise((resolve) => {
        const originalRatio = chart.options.devicePixelRatio || window.devicePixelRatio;
        chart.options.devicePixelRatio = resolution;
        chart.resize();
        setTimeout(() => { resolve(originalRatio); }, 250);
    });
}

async function withTitleShown(chart, callback) {
    const originalDisplay = chart.options.plugins.title.display;
    const originalText = chart.options.plugins.title.text;
    chart.options.plugins.title.display = true;
    chart.update();
    await callback(); 
    chart.options.plugins.title.display = originalDisplay;
    chart.options.plugins.title.text = originalText;
    chart.update();
}

async function downloadChartAsImage(type, id) {
    let chart;
    if (type === 'composition') { chart = (id === 'all') ? compositionChart : compositionChartInstances[id]; } else { chart = chartInstances[id]; }
    if (!chart) return;

    await withTitleShown(chart, async () => {
        const format = document.getElementById('imageFormat').value || 'png';
        const resolution = parseFloat(document.getElementById('pngResolution').value) || 1;
        const extension = format === 'jpeg' ? 'jpg' : 'png';
        const mimeType = `image/${format}`;
        const originalBgColor = chart.options.plugins.backgroundColor;
        if (format === 'jpeg') { chart.options.plugins.backgroundColor = 'white'; }
        
        const originalRatio = await setChartResolution(chart, resolution);
        const a = document.createElement('a');
        a.href = chart.toBase64Image(mimeType, 1.0);
        
        const box = chart.canvas.closest('.chart-box');
        const titleText = box ? box.querySelector('.chart-title-html').textContent : `ã‚°ãƒ©ãƒ•_${id}`;
        
        const fileName = titleText.replace(/[/\\?%*:|"<>]/g, '-') || `ã‚°ãƒ©ãƒ•`;
        a.download = (type === 'composition') ? `ç²’åº¦æ§‹æˆ_${fileName}.${extension}` : `${fileName}.${extension}`;
        a.click();
        
        chart.options.plugins.backgroundColor = originalBgColor;
        await setChartResolution(chart, originalRatio);
    });
}

async function downloadAllChartsAsZip() {
    if (Object.keys(chartInstances).length === 0) { return alert('ä¿å­˜ã™ã‚‹ã‚°ãƒ©ãƒ•ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); }
    const resolution = parseFloat(document.getElementById('pngResolution').value) || 1;
    const format = document.getElementById('imageFormat').value || 'png';
    const extension = format === 'jpeg' ? 'jpg' : 'png';
    const mimeType = `image/${format}`;
    
    try {
        const zip = new JSZip();
        const chartFolder = zip.folder("ç²’å¾„åŠ ç©æ›²ç·šã‚°ãƒ©ãƒ•");
        const chartIds = Object.keys(chartInstances);
        
        for (const id of chartIds) {
            const chart = chartInstances[id];
            await withTitleShown(chart, async () => {
                const originalBgColor = chart.options.plugins.backgroundColor;
                if (format === 'jpeg') { chart.options.plugins.backgroundColor = 'white'; }
                const originalRatio = await setChartResolution(chart, resolution);
                const base64 = chart.toBase64Image(mimeType, 1.0).split(';base64,').pop();
                
                const box = chart.canvas.closest('.chart-box');
                const titleText = box ? box.querySelector('.chart-title-html').textContent : `ã‚°ãƒ©ãƒ•_${id}`;
                const fileName = titleText.replace(/[/\\?%*:|"<>]/g, '-') || `ã‚°ãƒ©ãƒ•_${id}`;
                
                chartFolder.file(`${fileName}.${extension}`, base64, { base64: true });
                chart.options.plugins.backgroundColor = originalBgColor;
                await setChartResolution(chart, originalRatio);
            });
        }
        const content = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = 'ç²’å¾„åŠ ç©æ›²ç·šã‚°ãƒ©ãƒ•ä¸€å¼.zip';
        link.click();
        URL.revokeObjectURL(link.href);
    } catch(e) { console.error(e); alert('ZIPãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚'); }
}

async function exportToPowerPoint() {
    if (Object.keys(chartInstances).length === 0) { return alert('å‡ºåŠ›ã™ã‚‹ã‚°ãƒ©ãƒ•ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); }
    try {
        const pptx = new PptxGenJS();
        pptx.layout = 'LAYOUT_16x9';
        const resolution = parseFloat(document.getElementById('pngResolution').value) || 1;
        const chartBoxes = document.querySelectorAll('#chartsContainer .chart-box');
        
        for (const box of chartBoxes) {
            const groupKey = box.dataset.groupKey;
            const chart = chartInstances[groupKey];
            if(!chart) continue;

            const slide = pptx.addSlide();
            const originalBgColor = chart.options.plugins.backgroundColor;
            chart.options.plugins.backgroundColor = 'white';
            
            const originalRatio = await setChartResolution(chart, resolution);
            const base64 = chart.toBase64Image('image/png', 1.0);
            
            const titleHtml = box.querySelector('.chart-title-html');
            const title = titleHtml ? titleHtml.textContent : chart.options.plugins.title.text;
            
            const slideContentW = 9.0; const slideContentH = 4.5;
            const chartAspectRatio = chart.height / chart.width;
            let newW, newH;
            if (chartAspectRatio > (slideContentH / slideContentW)) { newH = slideContentH; newW = newH / chartAspectRatio; } 
            else { newW = slideContentW; newH = newW * chartAspectRatio; }
            const newX = (10.0 - newW) / 2; const newY = 0.85 + (slideContentH - newH) / 2;
            slide.addText(title, { x: 0.5, y: 0.25, w: '90%', h: 0.5, fontSize: 18, bold: true, align: 'center' });
            slide.addImage({ data: base64, x: newX, y: newY, w: newW, h: newH });
            chart.options.plugins.backgroundColor = originalBgColor;
            await setChartResolution(chart, originalRatio);
        }
        pptx.writeFile({ fileName: 'ç²’å¾„åŠ ç©æ›²ç·šã‚°ãƒ©ãƒ•.pptx' });
    } catch(e) { console.error(e); alert('PowerPointãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚'); }
}

async function exportCompositionToPowerPoint() {
    const container = document.getElementById('compositionContainer');
    const chartBoxes = container.querySelectorAll('.chart-box');
    
    if (chartBoxes.length === 0) { return alert('å‡ºåŠ›ã™ã‚‹ç²’åº¦æ§‹æˆã‚°ãƒ©ãƒ•ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); }
    try {
        const pptx = new PptxGenJS();
        pptx.layout = 'LAYOUT_16x9';
        const resolution = parseFloat(document.getElementById('pngResolution').value) || 1;
        
        for (const box of chartBoxes) {
            const canvas = box.querySelector('canvas');
            const chart = Chart.getChart(canvas);
            if(!chart) continue;

            const slide = pptx.addSlide();
            const originalBgColor = chart.options.plugins.backgroundColor;
            chart.options.plugins.backgroundColor = 'white';
            
            const originalRatio = await setChartResolution(chart, resolution);
            const base64 = chart.toBase64Image('image/png', 1.0);
            
            const titleHtml = box.querySelector('.chart-title-html');
            const title = titleHtml ? titleHtml.textContent : "";

            const slideContentW = 9.0; const slideContentH = 4.5;
            const chartAspectRatio = chart.height / chart.width;
            let newW, newH;
            if (chartAspectRatio > (slideContentH / slideContentW)) { newH = slideContentH; newW = newH / chartAspectRatio; } 
            else { newW = slideContentW; newH = newW * chartAspectRatio; }
            const newX = (10.0 - newW) / 2; const newY = 0.85 + (slideContentH - newH) / 2;
            slide.addText(title, { x: 0.5, y: 0.25, w: '90%', h: 0.5, fontSize: 18, bold: true, align: 'center' });
            slide.addImage({ data: base64, x: newX, y: newY, w: newW, h: newH });
            chart.options.plugins.backgroundColor = originalBgColor;
            await setChartResolution(chart, originalRatio);
        }
        pptx.writeFile({ fileName: 'ç²’åº¦æ§‹æˆã‚°ãƒ©ãƒ•.pptx' });
    } catch(e) { console.error(e); alert('PowerPointãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚'); }
}

async function downloadAllCompositionChartsAsZip() {
    const container = document.getElementById('compositionContainer');
    const chartBoxes = container.querySelectorAll('.chart-box');
    
    if (chartBoxes.length === 0) { return alert('ä¿å­˜ã™ã‚‹ç²’åº¦æ§‹æˆã‚°ãƒ©ãƒ•ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); }
    const resolution = parseFloat(document.getElementById('pngResolution').value) || 1;
    const format = document.getElementById('imageFormat').value || 'png';
    const extension = format === 'jpeg' ? 'jpg' : 'png';
    const mimeType = `image/${format}`;
    try {
        const zip = new JSZip();
        const chartFolder = zip.folder("ç²’åº¦æ§‹æˆã‚°ãƒ©ãƒ•");
        
        for (const box of chartBoxes) {
            const canvas = box.querySelector('canvas');
            const chart = Chart.getChart(canvas);
            if(!chart) continue;
            
            await withTitleShown(chart, async () => {
                const originalBgColor = chart.options.plugins.backgroundColor;
                if (format === 'jpeg') { chart.options.plugins.backgroundColor = 'white'; }
                const originalRatio = await setChartResolution(chart, resolution);
                const base64 = chart.toBase64Image(mimeType, 1.0).split(';base64,').pop();
                
                const titleHtml = box.querySelector('.chart-title-html');
                const title = titleHtml ? titleHtml.textContent : "graph";
                const fileName = title.replace(/[/\\?%*:|"<>]/g, '-') || `ã‚°ãƒ©ãƒ•`;
                
                chartFolder.file(`${fileName}.${extension}`, base64, { base64: true });
                chart.options.plugins.backgroundColor = originalBgColor;
                await setChartResolution(chart, originalRatio);
            });
        }
        const content = await zip.generateAsync({ type: 'blob' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = 'ç²’åº¦æ§‹æˆã‚°ãƒ©ãƒ•ä¸€å¼.zip';
        link.click();
        URL.revokeObjectURL(link.href);
    } catch(e) { console.error(e); alert('ZIPãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚'); }
}

// --- ã‚½ãƒ¼ãƒˆæ©Ÿèƒ½é–¢é€£ ---

let currentSortTarget = 'layer';

function openSortOrderModal() {
    document.getElementById('sortOrderModal').style.display = 'flex';
    switchSortTab('layer'); 
}

function closeSortOrderModal() {
    document.getElementById('sortOrderModal').style.display = 'none';
}

function switchSortTab(target) {
    currentSortTarget = target;
    document.getElementById('tabBtnLayer').classList.toggle('active', target === 'layer');
    document.getElementById('tabBtnSoil').classList.toggle('active', target === 'soilType');
    renderSortOrderList();
}

function renderSortOrderList() {
    const list = document.getElementById('sortOrderList');
    list.innerHTML = '';
    
    const currentItems = [...new Set(samples.map(s => {
        if (currentSortTarget === 'layer') return s.layer || 'ï¼ˆãªã—ï¼‰';
        return s.soilType || 'ï¼ˆãªã—ï¼‰';
    }))];

    let savedOrder = customSortOrders[currentSortTarget] || [];
    
    const orderedExistingItems = savedOrder.filter(item => currentItems.includes(item));
    const newItems = currentItems.filter(item => !savedOrder.includes(item)).sort();
    
    const displayList = [...orderedExistingItems, ...newItems];

    displayList.forEach(item => {
        const li = document.createElement('li');
        li.textContent = item;
        li.dataset.value = item;
        li.draggable = true;
        li.style.padding = '10px';
        li.style.border = '1px solid #d1d5db';
        li.style.marginBottom = '5px';
        li.style.backgroundColor = 'white';
        li.style.cursor = 'grab';
        li.style.borderRadius = '4px';
        list.appendChild(li);
    });

    setupSortDragAndDrop(list);
}

function setupSortDragAndDrop(list) {
    let draggedItem = null;
    list.addEventListener('dragstart', (e) => { 
        draggedItem = e.target; 
        setTimeout(() => e.target.style.opacity = '0.5', 0); 
    });
    list.addEventListener('dragend', (e) => { 
        e.target.style.opacity = '1'; 
        draggedItem = null;
    });
    list.addEventListener('dragover', (e) => {
        e.preventDefault();
        const afterElement = getDragAfterElement(list, e.clientY);
        if (afterElement == null) {
            list.appendChild(draggedItem);
        } else {
            list.insertBefore(draggedItem, afterElement);
        }
    });
}

function saveSortOrderSettings() {
    const list = document.getElementById('sortOrderList');
    const newOrder = [...list.querySelectorAll('li')].map(li => li.dataset.value);
    
    customSortOrders[currentSortTarget] = newOrder;
    
    closeSortOrderModal();
    renderAllCharts();
}

function getCustomSortedKeys(keys, criteria) {
    let orderList = [];
    if (criteria === 'layer') orderList = customSortOrders.layer;
    else if (criteria === 'soilType') orderList = customSortOrders.soilType;
    else return keys.sort((a, b) => String(a).localeCompare(String(b), undefined, { numeric: true }));
    
    if (!orderList || orderList.length === 0) {
        return keys.sort((a, b) => String(a).localeCompare(String(b), undefined, { numeric: true }));
    }

    return keys.sort((a, b) => {
        const getIndex = (val) => {
            let idx = orderList.indexOf(val);
            if (idx !== -1) return idx;
            idx = orderList.findIndex(orderItem => val.startsWith(orderItem));
            return idx !== -1 ? idx : 9999;
        };

        const idxA = getIndex(a);
        const idxB = getIndex(b);

        if (idxA !== idxB) return idxA - idxB;
        return String(a).localeCompare(String(b), undefined, { numeric: true });
    });
}

const imageExtractor={state:{targetGroupIndex:null,targetStandardIndex:null,step:0,image:null,calibrationPoints:[],curvePoints:[[],[]],activeCurveIndex:0,axisConfig:{xVal1:100,xVal2:.001,yVal1:0,yVal2:100,xLog:!0}},dom:{},instructions:["ç”»åƒã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„","Xè»¸ã®1ç‚¹ç›®ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ (ä¾‹: 100mm)","Xè»¸ã®2ç‚¹ç›®ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ (ä¾‹: 0.001mm)","Yè»¸ã®1ç‚¹ç›®ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ (ä¾‹: 0%)","Yè»¸ã®2ç‚¹ç›®ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ (ä¾‹: 100%)","æŠ½å‡ºã™ã‚‹æ›²ç·šã‚’é¸æŠã—ã€ç‚¹ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„"],axisLabels:["","Xè»¸ ç‚¹1ã®å€¤ (mm)","Xè»¸ ç‚¹2ã®å€¤ (mm)","Yè»¸ ç‚¹1ã®å€¤ (%)","Yè»¸ ç‚¹2ã®å€¤ (%)"],curveColors:["#3b82f6","#10b981"],init(){this.dom.modal=document.getElementById("imageExtractorModal"),this.dom.canvas=document.getElementById("extractorCanvas"),this.dom.ctx=this.dom.canvas.getContext("2d"),document.getElementById("extractorImageInput").addEventListener("change",this.handleImageUpload.bind(this)),document.getElementById("extractorResetBtn").addEventListener("click",this.reset.bind(this)),document.getElementById("extractorClearPointsBtn").addEventListener("click",this.clearPoints.bind(this)),document.getElementById("extractorAxisInput").addEventListener("input",this.handleAxisInput.bind(this)),document.getElementById("applyExtractedDataBtn").addEventListener("click",this.applyData.bind(this)),document.getElementById("exportExtractedCSVBtn").addEventListener("click",this.exportExtractedCSV.bind(this)),this.dom.canvas.addEventListener("click",this.handleCanvasClick.bind(this))},open(a,t){this.state.targetGroupIndex=a,this.state.targetStandardIndex=t,this.dom.modal.style.display="flex";const e=standardGroups[a].standards[t];e.extractorState?this.loadState(e.extractorState):this.reset(!1)},close(){this.dom.modal.style.display="none"},loadState(a){const t=new Image;t.onload=()=>{this.state.image=t,this.state.calibrationPoints=a.calibrationPoints,this.state.curvePoints=a.curvePoints,this.state.axisConfig=a.axisConfig,this.state.step=5,document.getElementById("extractorUploadArea").classList.add("hidden"),document.getElementById("extractorMainArea").classList.remove("hidden"),document.getElementById("extractorAxisInputArea").classList.add("hidden"),document.getElementById("extractorExtractArea").classList.remove("hidden"),this.updateInstruction(),this.switchCurve(0),this.updateActionButtons(),this.drawCanvas()},t.src=a.imageSrc},zoom(a){const t=this.dom.canvas,e=t.clientWidth*a;t.style.width=`${e}px`,t.style.height="auto"},handleImageUpload(a){const t=a.target.files[0];if(!t)return;const e=new FileReader;e.onload=a=>{const t=new Image;t.onload=()=>{this.state.image=t,this.dom.canvas.style.width="auto",this.dom.canvas.style.height="auto",this.reset(!0,!1)},t.src=a.target.result},e.readAsDataURL(t),a.target.value=""},handleCanvasClick(a){if(!this.state.image)return;const t=this.dom.canvas,e=t.getBoundingClientRect(),o=t.width/e.width,s=t.height/e.height,l=(a.clientX-e.left)*o,n=(a.clientY-e.top)*s;this.state.step>=1&&this.state.step<=4?(this.state.calibrationPoints.push({x:l,y:n}),this.state.step++,5===this.state.step&&(document.getElementById("extractorAxisInputArea").classList.add("hidden"),document.getElementById("extractorExtractArea").classList.remove("hidden"),this.switchCurve(0)),this.updateInstruction()):5===this.state.step&&(this.state.curvePoints[this.state.activeCurveIndex].push({x:l,y:n}),this.updateActionButtons()),this.drawCanvas()},handleAxisInput(a){const t=parseFloat(a.target.value);if(isNaN(t))return;const e=this.state.step;1===e?this.state.axisConfig.xVal1=t:2===e?this.state.axisConfig.xVal2=t:3===e?this.state.axisConfig.yVal1=t:4===e&&(this.state.axisConfig.yVal2=t)},switchCurve(a){this.state.activeCurveIndex=a,document.getElementById("upperCurveBtn").classList.toggle("active",0===a),document.getElementById("lowerCurveBtn").classList.toggle("active",1===a)},updateInstruction(){document.getElementById("extractorInstruction").textContent=`ã‚¹ãƒ†ãƒƒãƒ— ${this.state.step}: ${this.instructions[this.state.step]}`;const a=document.getElementById("extractorAxisInput"),t=document.getElementById("extractorAxisLabel");this.state.step>=1&&this.state.step<=4&&(t.textContent=this.axisLabels[this.state.step],1===this.state.step?a.value=this.state.axisConfig.xVal1:2===this.state.step?a.value=this.state.axisConfig.xVal2:3===this.state.step?a.value=this.state.axisConfig.yVal1:4===this.state.step&&(a.value=this.state.axisConfig.yVal2))},drawCanvas(){if(!this.state.image)return;const a=this.dom.canvas,t=this.dom.ctx;a.width=this.state.image.width,a.height=this.state.image.height,t.drawImage(this.state.image,0,0),this.state.calibrationPoints.forEach((a,e)=>{t.fillStyle="red",t.strokeStyle="white",t.lineWidth=2,t.beginPath(),t.arc(a.x,a.y,8,0,2*Math.PI),t.fill(),t.stroke(),t.fillStyle="white",t.font="bold 16px sans-serif",t.textAlign="center",t.textBaseline="middle",t.fillText(e+1,a.x,a.y)}),this.state.curvePoints.forEach((a,e)=>{const o=this.curveColors[e];a.forEach(a=>{t.fillStyle=o,t.strokeStyle="white",t.lineWidth=2,t.beginPath(),t.arc(a.x,a.y,5,0,2*Math.PI),t.fill(),t.stroke()}),a.length>1&&(t.strokeStyle=o,t.lineWidth=2,t.beginPath(),[...a].sort((a,t)=>a.x-t.x).forEach((a,e)=>0==e?t.moveTo(a.x,a.y):t.lineTo(a.x,a.y)),t.stroke())})},reset(a=!0,t=!0){t&&(this.state.image=null,this.dom.canvas.style.width="auto",this.dom.canvas.style.height="auto"),this.state.step=this.state.image?1:0,this.resetState(),document.getElementById("extractorMainArea").classList.toggle("hidden",!this.state.image),document.getElementById("extractorUploadArea").classList.toggle("hidden",!!this.state.image),document.getElementById("extractorAxisInputArea").classList.toggle("hidden",!this.state.image||this.state.step>=5),document.getElementById("extractorExtractArea").classList.add("hidden"),this.state.image||this.dom.ctx.clearRect(0,0,this.dom.canvas.width,this.dom.canvas.height),this.updateInstruction(),this.updateActionButtons(),this.drawCanvas()},resetState(){Object.assign(this.state,{calibrationPoints:[],curvePoints:[[],[]],activeCurveIndex:0})},clearPoints(){this.state.step<5||(this.state.curvePoints[this.state.activeCurveIndex]=[],this.updateActionButtons(),this.drawCanvas())},updateActionButtons(){const a=this.state.curvePoints.some(a=>a.length>0);document.getElementById("applyExtractedDataBtn").disabled=!a,document.getElementById("exportExtractedCSVBtn").disabled=!a},pixelToValue(a,t){if(this.state.calibrationPoints.length<4)return null;const[e,o,s,l]=this.state.calibrationPoints,{xVal1:n,xVal2:i,yVal1:d,yVal2:r,xLog:c}=this.state.axisConfig,h=(a-e.x)/(o.x-e.x),p=c?Math.pow(10,Math.log10(n)+h*(Math.log10(i)-Math.log10(n))):n+h*(i-n),u=(t-s.y)/(l.y-s.y);return{x:p,y:d+u*(r-d)}},processAndSortPoints(a){return a.map(a=>this.pixelToValue(a.x,a.y)).filter(Boolean).map(a=>({grainSize:parseFloat(a.x.toPrecision(3)),passingPercent:Math.max(0,Math.min(100,a.y)).toFixed(2)}))},
applyData(){const{targetGroupIndex:a,targetStandardIndex:t,curvePoints:e}=this.state;if(null==a||null==t||e.every(a=>0===a.length))return;const o=this.processAndSortPoints(e[0]),s=this.processAndSortPoints(e[1]),l="# ä¸Šé™\n"+o.sort((a,t)=>a.grainSize-t.grainSize).map(a=>`${a.grainSize}\t${a.passingPercent}`).join("\n"),n="# ä¸‹é™\n"+s.sort((a,t)=>a.grainSize-t.grainSize).map(a=>`${a.grainSize}\t${a.passingPercent}`).join("\n"),c=document.getElementById("extractorCombineFill").checked,i=o.length>0,d=s.length>0,r=standardGroups[a],g=r.standards[t];if(c){g.dataStr=i&&d?`${l}\n---\n${n}`:i?l:n.replace("# ä¸‹é™\n","# ãƒ‡ãƒ¼ã‚¿\n"),g.fill=i&&d,g.extractorState=this.getExtractorState(),alert("ãƒ‡ãƒ¼ã‚¿ã‚’å¡—ã‚Šã¤ã¶ã—ç¯„å›²ã¨ã—ã¦åæ˜ ã—ã¾ã—ãŸã€‚")}else{let e=!1;if(i){g.dataStr=l,g.fill=!1,g.name=g.name.replace(" (ä¸‹é™)","")+" (ä¸Šé™)",g.extractorState=this.getExtractorState(),e=!0}if(d){const t={id:Date.now()+Math.random(),name:g.name.replace(" (ä¸Šé™)","")+" (ä¸‹é™)",comment:g.comment,visible:!0,fill:!1,color:"#"+("000000"+(16777215-parseInt(g.color.substring(1),16)).toString(16)).slice(-6),opacity:.8,dataStr:n,extractorState:this.getExtractorState()};i?(r.standards.splice(a+1,0,t),alert("ä¸Šé™ã¨ä¸‹é™ã‚’2ã¤ã®ç‹¬ç«‹ã—ãŸç·šã¨ã—ã¦è¿½åŠ ãƒ»æ›´æ–°ã—ã¾ã—ãŸã€‚")):Object.assign(g,t)}else e||alert("ãƒ‡ãƒ¼ã‚¿ã‚’1ã¤ã®ç·šã¨ã—ã¦åæ˜ ã—ã¾ã—ãŸã€‚")}saveStandardsToLocalStorage(),renderReferenceStandardsTable(a),renderAllCharts(),this.close()},getExtractorState(){return{imageSrc:this.state.image.src,calibrationPoints:this.state.calibrationPoints,curvePoints:this.state.curvePoints,axisConfig:this.state.axisConfig}},
exportExtractedCSV(){const a=this.processAndSortPoints(this.state.curvePoints[0]).sort((a,t)=>t.grainSize-a.grainSize),t=this.processAndSortPoints(this.state.curvePoints[1]).sort((a,t)=>t.grainSize-a.grainSize);if(0===a.length&&0===t.length)return alert("ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚");let e="curve_type,grain_size_mm,passing_percent_%\n";a.forEach(a=>{e+=`upper,${a.grainSize},${a.passingPercent}\n`}),t.forEach(a=>{e+=`lower,${a.grainSize},${a.passingPercent}\n`});const o=new Blob(["\ufeff"+e],{type:"text/csv;charset=utf-8;"}),s=document.createElement("a");s.href=URL.createObjectURL(o),s.download="extracted_grain_size_data.csv",s.click(),URL.revokeObjectURL(s.href)}};

let processedDataForImport = [];
let listHot, resultsHot;

function openDataProcessorModal() {
    document.getElementById('dataProcessorModal').style.display = 'flex';
    // Handsontableã®åˆæœŸåŒ–ãƒ»æç”»ã‚ºãƒ¬é˜²æ­¢
    setTimeout(() => {
        initializeHandsontables();
        backToInput();
        if(listHot) listHot.render();
        if(resultsHot) resultsHot.render();
    }, 100);
}

function closeDataProcessorModal() {
    document.getElementById('dataProcessorModal').style.display = 'none';
}

function backToInput() {
    document.getElementById('processorInputArea').style.display = 'flex';
    document.getElementById('processorPreviewArea').style.display = 'none';
}

function initializeHandsontables() {
    const listContainer = document.getElementById('listTableContainer');
    const resultsContainer = document.getElementById('resultsTableContainer');
    if (listHot) { listHot.destroy(); listHot = null; }
    if (resultsHot) { resultsHot.destroy(); resultsHot = null; }

    const commonSettings = {
        startRows: 20,
        startCols: 10,
        rowHeaders: true,
        colHeaders: true,
        height: '100%',
        width: '100%',
        contextMenu: [
            { key: 'row_above', name: 'ä¸Šã«è¡Œã‚’æŒ¿å…¥' },
            { key: 'row_below', name: 'ä¸‹ã«è¡Œã‚’æŒ¿å…¥' },
            { key: 'remove_row', name: 'è¡Œã‚’å‰Šé™¤' },
            { name: '---------' },
            { key: 'undo', name: 'å…ƒã«æˆ»ã™' },
            { key: 'redo', name: 'ã‚„ã‚Šç›´ã—' }
        ],
        manualRowMove: true,
        manualColumnMove: true,
        manualRowResize: true,
        manualColumnResize: true,
        copyPaste: { pasteMode: 'shift_down' },
        minSpareRows: 1,
    };

    listHot = new Handsontable(listContainer, {
        ...commonSettings,
        colHeaders: ['åœ°ç‚¹å', 'è©¦æ–™å', 'æ·±åº¦(m)', 'åœŸè³ªå', 'åœŸå±¤'],
        columns: [{}, {}, {}, {}, {}],
        startCols: 5,
    });

    resultsHot = new Handsontable(resultsContainer, {
        ...commonSettings,
        colHeaders: (index) => (index % 2 === 0) ? 'ç²’å¾„ (mm)' : 'é€šéç‡ (%)',
        startCols: 10,
    });
}
function processPastedData() {
    const listData = listHot.getData();
    const resultsDataRaw = resultsHot.getSourceData();
    if (listData.length === 0) { return alert('ã€Œ1. è©¦é¨“ä¸€è¦§è¡¨ãƒ‡ãƒ¼ã‚¿ã€ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'); }
    if (resultsDataRaw.filter(row => row.some(cell => cell !== null && cell !== '')).length === 0) { return alert('ã€Œ2. ç²’åº¦è©¦é¨“çµæœãƒ‡ãƒ¼ã‚¿ã€ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚'); }
    try {
        const sampleList = parseListTable(listData);
        if(sampleList.length === 0) { return alert('æœ‰åŠ¹ãªè©¦é¨“ä¸€è¦§è¡¨ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã€Œè©¦æ–™åã€ãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚'); }
        const resultsData = parseResultsTable(resultsDataRaw, sampleList.length);
        const combinedData = [];
        sampleList.forEach((meta, i) => {
            const points = resultsData[i];
            const validPoints = points.filter(p => p.y !== '' && !isNaN(p.y));
            if (validPoints.length > 0) {
                const dataStr = validPoints.map(p => `${p.x}\t${p.y}`).join('\n');
                combinedData.push({ ...meta, dataStr, pointsCount: validPoints.length });
            }
        });
        if (combinedData.length === 0) { return alert('æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã‚’æ¤œå‡ºã§ãã¾ã›ã‚“ã§ã—ãŸã€‚å…¥åŠ›ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã®å½¢å¼ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚'); }
        generatePreview(combinedData);
        processedDataForImport = combinedData;
        document.getElementById('processorInputArea').style.display = 'none';
        document.getElementById('processorPreviewArea').style.display = 'flex';
    } catch (e) { console.error("ãƒ‡ãƒ¼ã‚¿è§£æã‚¨ãƒ©ãƒ¼:", e); alert(`ãƒ‡ãƒ¼ã‚¿ã®è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\n\nã‚¨ãƒ©ãƒ¼å†…å®¹: ${e.message}`); }
}

function parseListTable(data) {
    const sampleList = [];
    data.forEach(row => {
        const name = row[1] ? String(row[1]).trim() : null;
        if (name) {
            sampleList.push({ location: String(row[0] || '').trim(), name: name, depth: String(row[2] || '').trim(), soilType: String(row[3] || '').trim(), layer: String(row[4] || '1').trim() });
        }
    });
    return sampleList;
}

function parseResultsTable(data, numberOfSamples) {
    const results = Array.from({ length: numberOfSamples }, () => []);
    if (numberOfSamples === 0) { throw new Error("è©¦é¨“ä¸€è¦§è¡¨ã«å‡¦ç†å¯¾è±¡ã®è©¦æ–™ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚"); }
    data.forEach(row => {
        if (!row.some(cell => cell !== null && cell !== '')) return;
        for (let i = 0; i < numberOfSamples; i++) {
            const sizeColIndex = i * 2; const passColIndex = sizeColIndex + 1;
            if (row.length > sizeColIndex) {
                const sizeStr = String(row[sizeColIndex] || '').trim();
                if (sizeStr) {
                    const size = parseFloat(sizeStr);
                    if (!isNaN(size)) {
                        const percentStr = (row.length > passColIndex) ? String(row[passColIndex] || '').trim() : '';
                        const percent = parseFloat(percentStr);
                        results[i].push({ x: size, y: !isNaN(percent) ? percent : '' });
                    }
                }
            }
        }
    });
    return results;
}

function generatePreview(data) {
    const table = document.getElementById('processorPreviewTable');
    let html = `<thead><tr><th>åœ°ç‚¹å</th><th>è©¦æ–™å</th><th>æ·±åº¦(m)</th><th>åœŸè³ªå</th><th>åœŸå±¤</th><th>ãƒ‡ãƒ¼ã‚¿ç‚¹æ•°</th></tr></thead><tbody>`;
    data.forEach(d => { html += `<tr><td>${d.location}</td><td>${d.name}</td><td>${d.depth}</td><td>${d.soilType}</td><td>${d.layer}</td><td>${d.pointsCount}</td></tr>`; });
    html += '</tbody>';
    table.innerHTML = html;
}

function confirmImport() {
    if (processedDataForImport.length === 0) { return alert('èª­ã¿è¾¼ã‚€ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); }
    let addedCount = 0, updatedCount = 0;
    processedDataForImport.forEach(d => {
        const existingIndex = samples.findIndex(s => s.location === d.location && s.name === d.name && s.layer === d.layer);
        if (existingIndex !== -1) { Object.assign(samples[existingIndex], { depth: d.depth, soilType: d.soilType, dataStr: d.dataStr }); updatedCount++; } 
        else { samples.push({ id: Date.now() + Math.random(), ...d }); addedCount++; }
    });
    alert(`${addedCount}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ–°è¦è¿½åŠ ã—ã€${updatedCount}ä»¶ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚`);
    closeDataProcessorModal();
    renderTable(); renderAllCharts();
}

function openLayerOrderModal() {
    const modal = document.getElementById('layerOrderModal');
    const list = document.getElementById('layerOrderList');
    let soilTypes = [...new Set(samples.map(s => s.soilType || 'ï¼ˆåœŸè³ªåãªã—ï¼‰'))];
    soilTypes.sort((a, b) => String(a).localeCompare(String(b), undefined, { numeric: true }));
    list.innerHTML = '';
    if (soilTypes.length === 0) { list.innerHTML = '<p class="help-text" style="text-align:center;">ç•ªå·ã‚’å‰²ã‚Šå½“ã¦ã‚‹åœŸè³ªåãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>'; } 
    else {
        soilTypes.forEach(soilTypeName => {
            const li = document.createElement('li');
            li.textContent = soilTypeName; li.draggable = true; li.dataset.soilType = soilTypeName;
            list.appendChild(li);
        });
    }
    modal.style.display = 'flex';
}

function closeLayerOrderModal() { document.getElementById('layerOrderModal').style.display = 'none'; }

function saveLayerOrder() {
    if (!confirm('ã€ŒåœŸè³ªåã€ã®é †åºã«åŸºã¥ã„ã¦ã€ãƒ‡ãƒ¼ã‚¿ä¸€è¦§è¡¨ã®ã€ŒåœŸå±¤ã€åˆ—ã‚’ç•ªå·(1, 2, 3...)ã§ä¸Šæ›¸ãã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) { return; }
    const list = document.getElementById('layerOrderList');
    const newOrderOfSoilTypes = [...list.querySelectorAll('li')].map(li => li.dataset.soilType);
    const soilTypeMap = new Map(newOrderOfSoilTypes.map((soilTypeName, index) => [soilTypeName, index + 1]));
    samples.forEach(sample => {
        const originalSoilType = sample.soilType || 'ï¼ˆåœŸè³ªåãªã—ï¼‰';
        if (soilTypeMap.has(originalSoilType)) { sample.layer = soilTypeMap.get(originalSoilType).toString(); }
    });
    alert('ã€ŒåœŸå±¤ã€åˆ—ã®ç•ªå·ã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚');
    closeLayerOrderModal();
    renderTable(); renderAllCharts();
}

function setupLayerOrderModalDragAndDrop() {
    const list = document.getElementById('layerOrderList');
    let draggedItem = null;
    list.addEventListener('dragstart', (e) => { draggedItem = e.target; setTimeout(() => e.target.classList.add('dragging'), 0); });
    list.addEventListener('dragend', (e) => { e.target.classList.remove('dragging'); });
    list.addEventListener('dragover', (e) => {
        e.preventDefault();
        const afterElement = getDragAfterElement(list, e.clientY);
        list.insertBefore(draggedItem, afterElement);
    });
}

function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('li:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        return (offset < 0 && offset > closest.offset) ? { offset, element: child } : closest;
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

function saveAppState() {
    if (samples.length === 0 && standardGroups.length === 0) { return alert('ä¿å­˜ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'); }
    // customSortOrdersã‚‚ä¿å­˜å¯¾è±¡ã«è¿½åŠ 
    const appState = { samples, standardGroups, customLayerOrder, customSortOrders };
    const blob = new Blob([JSON.stringify(appState, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    const now = new Date();
    const y = now.getFullYear();
    const m = String(now.getMonth() + 1).padStart(2, '0');
    const d = String(now.getDate()).padStart(2, '0');
    const h = String(now.getHours()).padStart(2, '0');
    const min = String(now.getMinutes()).padStart(2, '0');
    a.download = `ç²’åº¦è©¦é¨“æ•´ç†_${y}${m}${d}_${h}${min}.json`;
    a.click();
    URL.revokeObjectURL(a.href);
}

function handleAppStateImport(event) {
    handleFileRead(event.target.files[0], (text) => {
        try {
            const loadedState = JSON.parse(text);
            if (!loadedState.samples || !loadedState.standardGroups) { throw new Error('ç„¡åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼ã§ã™ã€‚'); }
            if (!confirm('ç¾åœ¨ã®ä½œæ¥­å†…å®¹ãŒç ´æ£„ã•ã‚Œã€ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã«ç½®ãæ›ã‚ã‚Šã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ')) { return; }
            samples = loadedState.samples || [];
            standardGroups = loadedState.standardGroups || [];
            customLayerOrder = loadedState.customLayerOrder || [];
            // ã‚½ãƒ¼ãƒˆé †ã®èª­ã¿è¾¼ã¿
            if (loadedState.customSortOrders) {
                customSortOrders = loadedState.customSortOrders;
            } else {
                customSortOrders = { layer: [], soilType: [] };
            }

            renderTable();
            saveStandardsToLocalStorage();
            populateStandardGroupSelector();
            renderReferenceStandardsTable();
            renderAllCharts();
            alert('çŠ¶æ…‹ã‚’æ­£å¸¸ã«èª­ã¿è¾¼ã¿ã¾ã—ãŸã€‚');
        } catch (e) { console.error(e); alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒ•ã‚¡ã‚¤ãƒ«ãŒç ´æã—ã¦ã„ã‚‹ã‹ã€å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ã€‚'); }
    });
    event.target.value = '';
}
</script>
</body>
</html>